[{"name":"Array.Extra","comment":" Convenience functions for working with `Array`\n\n\n# Predicates\n\n@docs all, any, member\n\n\n# Alter\n\n@docs reverse, intersperse, update, pop, removeAt, insertAt\n\n\n# Filtering\n\n@docs removeWhen, filterMap\n\n\n# Getting slices of an array\n\n@docs sliceFrom, sliceUntil, splitAt, unzip\n\n\n# Combining arrays\n\n@docs interweave_, andMap, map2, map3, map4, map5, zip, zip3\n\n\n# Resizing\n\n@docs resizelRepeat, resizerRepeat, resizelIndexed, resizerIndexed\n\n\n# To List\n\n@docs mapToList, indexedMapToList\n\n","unions":[],"aliases":[],"values":[{"name":"all","comment":" Whether all elements satisfy a given test.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 2, 4 ] |> all (\\x -> x < 5)\n    --> True\n\n    fromList [ 4, 16 ] |> all (\\x -> x < 5)\n    --> False\n\n    empty |> all (\\x -> x < 5)\n    --> True\n\n","type":"(a -> Basics.Bool) -> Array.Array a -> Basics.Bool"},{"name":"andMap","comment":" Map functions taking multiple arguments over multiple arrays. Each array should be of the same length; extra elements are dropped.\n\n    import Array exposing (Array)\n\n    toIntFunctions : Array (Float -> Int)\n    toIntFunctions =\n        Array.fromList\n            [ round\n            , floor\n            , ceiling\n            , truncate\n            ]\n\n    toIntFunctions\n        |> andMap (Array.fromList [ -1.5, -1.5, -1.5, -1.5 ])\n        --> Array.fromList [ -1, -2, -1, -1 ]\n\n","type":"Array.Array a -> Array.Array (a -> b) -> Array.Array b"},{"name":"any","comment":" Whether at least some elements satisfy a given test.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 6, 3 ] |> any (\\x -> x < 5)\n    --> True\n\n    fromList [ 12, 33 ] |> any (\\x -> x < 5)\n    --> False\n\n    empty |> any (\\x -> x < 5)\n    --> False\n\n","type":"(a -> Basics.Bool) -> Array.Array a -> Basics.Bool"},{"name":"filterMap","comment":" Try transforming all elements but only keep the successes.\n\n    import Array exposing (fromList)\n\n    fromList [ \"3\", \"4.0\", \"5\", \"hats\" ]\n        |> filterMap String.toInt\n    --> fromList [ 3, 5 ]\n\n","type":"(a -> Maybe.Maybe b) -> Array.Array a -> Array.Array b"},{"name":"indexedMapToList","comment":" Transform all elements with their indexes as the first argument\nand collect the result in a `List`.\n\n    import Array exposing (Array, fromList)\n    import Html exposing (Html)\n\n    type alias Exercise =\n        { name : String }\n\n    exerciseRender : Int -> Exercise -> Html msg\n    exerciseRender index =\n        \\exercise ->\n            String.concat\n                [ \"Exercise #\"\n                , String.fromInt (index + 1)\n                , \" - \"\n                , exercise.name\n                ]\n                |> Html.text\n\n    exercisesRender : Array Exercise -> Html msg\n    exercisesRender =\n        indexedMapToList renderExercise\n            >> Html.div []\n\n","type":"(Basics.Int -> a -> b) -> Array.Array a -> List.List b"},{"name":"insertAt","comment":" Insert an element at a given index.\nIf the index is out of bounds, nothing is changed.\n\n    import Array exposing (fromList)\n\n    fromList [ 'a', 'c' ] |> insertAt 1 'b'\n    --> fromList [ 'a', 'b', 'c' ]\n\n    fromList [ 'a', 'c' ] |> insertAt -1 'b'\n    --> fromList [ 'a', 'c' ]\n\n    fromList [ 'a', 'c' ] |>  insertAt 100 'b'\n    --> fromList [ 'a', 'c' ]\n\n","type":"Basics.Int -> a -> Array.Array a -> Array.Array a"},{"name":"intersperse","comment":" Place a value between all elements.\n\n    import Array exposing (fromList)\n\n    fromList [ \"turtles\", \"turtles\", \"turtles\" ]\n        |> intersperse \"on\"\n    --> fromList\n    -->     [ \"turtles\", \"on\", \"turtles\", \"on\", \"turtles\" ]\n\nTo interlace an `Array`, [`interweave_`](#interweave_).\n\n","type":"a -> Array.Array a -> Array.Array a"},{"name":"interweave_","comment":" Return an array that contains elements from the two provided, in alternate order.\nIf one array runs out of items, append the items from the remaining array.\n\n    import Array exposing (fromList, repeat)\n\n    interweave_ (fromList [ \"turtles\", \"turtles\", \"turtles\" ]) (repeat 2 \"on\")\n    --> fromList [ \"turtles\", \"on\", \"turtles\", \"on\", \"turtles\" ]\n\n    interweave_ (fromList [ \"turtles\", \"turtles\", \"turtles\" ]) (repeat 5 \"on\")\n    --> fromList [ \"turtles\", \"on\", \"turtles\", \"on\", \"turtles\", \"on\", \"on\", \"on\" ]\n\n    interweave_ (fromList [ \"turtles\", \"turtles\", \"turtles\" ]) (repeat 1 \"on\")\n    --> fromList [ \"turtles\", \"on\", \"turtles\", \"turtles\" ]\n\n","type":"Array.Array a -> Array.Array a -> Array.Array a"},{"name":"map2","comment":" Combine the elements of two `Array`s with a given function.\nIf one `Array` is longer, its extra elements are not used.\n\n    import Array exposing (fromList)\n\n    map2 (\\a b -> a + b)\n        (fromList [ 1, 2, 3 ])\n        (fromList [ 1, 2, 3, 4 ])\n    --> fromList [ 2, 4, 6 ]\n\n    map2 Tuple.pair\n        (fromList [ 1, 2, 3 ])\n        (fromList [ 'a', 'b' ])\n    --> fromList [ ( 1, 'a' ), ( 2, 'b' ) ]\n\nNote: [`zip`](Array-Extra#zip) can be used instead of `map2 Tuple.pair`.\n\n","type":"(a -> b -> combined) -> Array.Array a -> Array.Array b -> Array.Array combined"},{"name":"map3","comment":" Combine the elements of three `Array`s with the given function. See [`map2`](Array-Extra#map2).\n\nNote: [`zip3`](Array-Extra#zip3) can be used instead of `map3 (\\a b c -> ( a, b, c ))`.\n\n","type":"(a -> b -> c -> combined) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array combined"},{"name":"map4","comment":" Combine the elements of four `Array`s with the given function. See [`map2`](Array-Extra#map2).\n","type":"(a -> b -> c -> d -> combined) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array combined"},{"name":"map5","comment":" Combine the elements of five `Array`s with the given function. See [`map2`](Array-Extra#map2).\n","type":"(a -> b -> c -> d -> e -> combined) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array e -> Array.Array combined"},{"name":"mapToList","comment":" Apply a function to the elements in the array and collect the result in a List.\n\n    import Array exposing (fromList)\n    import Html\n\n    fromList [ \"a\", \"b\", \"c\" ]\n        |> mapToList Html.text\n    --> [ Html.text \"a\", Html.text \"b\", Html.text \"c\" ]\n\n","type":"(a -> b) -> Array.Array a -> List.List b"},{"name":"member","comment":" Whether a given value is contained.\n\n    import Array exposing (fromList)\n\n    fromList [ \"Leonardo\", \"Michelangelo\", \"Donatello\", \"Raphael\" ]\n        |> member \"Donatello\"\n    --> True\n\n    fromList [ \"Leonardo\", \"Michelangelo\" ]\n        |> member \"Raphael\"\n    --> False\n\nFor checking if some aspect is present, use [`any`](#any).\n\n","type":"a -> Array.Array a -> Basics.Bool"},{"name":"pop","comment":" Remove the last element.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 1, 2, 3 ] |> pop\n    --> fromList [ 1, 2 ]\n\n    empty |> pop\n    --> empty\n\n","type":"Array.Array a -> Array.Array a"},{"name":"removeAt","comment":" Remove the element at a given index.\nIf the index is out of bounds, nothing is changed.\n\n    import Array exposing (fromList)\n\n    fromList [ 1, 2, 3, 4 ] |> removeAt 2\n    --> fromList [ 1, 2, 4 ]\n\n    fromList [ 1, 2, 3, 4 ] |> removeAt -1\n    --> fromList [ 1, 2, 3, 4 ]\n\n    fromList [ 1, 2, 3, 4 ] |> removeAt 100\n    --> fromList [ 1, 2, 3, 4 ]\n\n","type":"Basics.Int -> Array.Array a -> Array.Array a"},{"name":"removeWhen","comment":" Only keep elements which fail to satisfy a given predicate.\nThis is equivalent to `Array.filter (not << predicate)`.\n\n    import Array exposing (fromList)\n\n    fromList [ -1, 92, 0, 14, -3 ]\n        |> removeWhen (\\x -> x < 0)\n    --> fromList [ 92, 0, 14 ]\n\n","type":"(a -> Basics.Bool) -> Array.Array a -> Array.Array a"},{"name":"resizelIndexed","comment":" Resize from the left, padding the right-hand side with a given value based on index.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 'a', 'b', 'c' ]\n        |> resizelIndexed 5 toLetterInAlphabet\n    --> fromList [ 'a', 'b', 'c', 'd', 'e' ]\n\n    fromList [ 'a', 'b', 'c' ]\n        |> resizelIndexed 2 toLetterInAlphabet\n    --> fromList [ 'a', 'b' ]\n\n    fromList [ 'a', 'b', 'c' ]\n        |> resizelIndexed -1 toLetterInAlphabet\n    --> empty\n\n    toLetterInAlphabet : Int -> Char\n    toLetterInAlphabet inAlphabet =\n        Char.fromCode ((Char.toCode 'a') + inAlphabet)\n\n","type":"Basics.Int -> (Basics.Int -> a) -> Array.Array a -> Array.Array a"},{"name":"resizelRepeat","comment":" Resize from the left, padding the right-hand side with a given value.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 1, 2 ] |> resizelRepeat 4 0\n    --> fromList [ 1, 2, 0, 0 ]\n\n    fromList [ 1, 2, 3 ] |> resizelRepeat 2 0\n    --> fromList [ 1, 2 ]\n\n    fromList [ 1, 2 ] |> resizelRepeat -1 0\n    --> empty\n\n","type":"Basics.Int -> a -> Array.Array a -> Array.Array a"},{"name":"resizerIndexed","comment":" Resize from the right, padding the left-hand side with a given value based on index.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 10, 25, 36 ]\n        |> resizerIndexed 5 (\\n -> n * 5)\n    --> fromList [ 0, 5, 10, 25, 36 ]\n\n    fromList [ 10, 25, 36 ]\n        |> resizerIndexed 2 (\\n -> n * 5)\n    --> fromList [ 25, 36 ]\n\n    fromList [ 10, 25, 36 ]\n        |> resizerIndexed -1 (\\n -> n * 5)\n    --> empty\n\n","type":"Basics.Int -> (Basics.Int -> a) -> Array.Array a -> Array.Array a"},{"name":"resizerRepeat","comment":" Resize from the right, padding the left-hand side with a given value.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 1, 2 ] |> resizerRepeat 4 0\n    --> fromList [ 0, 0, 1, 2 ]\n\n    fromList [ 1, 2, 3 ] |> resizerRepeat 2 0\n    --> fromList [ 2, 3 ]\n\n    fromList [ 1, 2 ] |> resizerRepeat -1 0\n    --> empty\n\n","type":"Basics.Int -> a -> Array.Array a -> Array.Array a"},{"name":"reverse","comment":" Flip the element order.\n\n    import Array exposing (fromList)\n\n    fromList [ 1, 2, 3, 4 ] |> reverse\n    --> fromList [ 4, 3, 2, 1 ]\n\n","type":"Array.Array a -> Array.Array a"},{"name":"sliceFrom","comment":" Drop a given number of elements from the start.\nIn other words, slice the `Array` from an index until the very end.\nGiven a negative argument, count the end of the slice from the end.\n\n    import Array exposing (fromList)\n\n    fromList (List.range 0 6) |> sliceFrom 3\n    --> fromList [ 3, 4, 5, 6 ]\n\n    fromList (List.range 0 6) |> sliceFrom -3\n    --> fromList [ 4, 5, 6 ]\n\n","type":"Basics.Int -> Array.Array a -> Array.Array a"},{"name":"sliceUntil","comment":" Take a number of elements from the start.\nIn other words, slice the `Array` from the very beginning until not including the index.\nGiven a negative argument, count the beginning of the slice from the end.\n\n    import Array exposing (fromList)\n\n    fromList (List.range 0 6) |> sliceUntil 3\n    --> fromList [ 0, 1, 2 ]\n\n    fromList (List.range 0 6) |> sliceUntil -3\n    --> fromList [ 0, 1, 2, 3 ]\n\n","type":"Basics.Int -> Array.Array a -> Array.Array a"},{"name":"splitAt","comment":" Split into two `Array`s, the first ending before and the second starting with a given index.\n\n    import Array exposing (fromList, empty)\n\n    fromList [ 1, 2, 3, 4 ] |> splitAt 2\n    --> ( fromList [ 1, 2 ], fromList [ 3, 4 ] )\n\n    fromList [ 1, 2, 3, 4 ] |> splitAt 100\n    --> ( fromList [ 1, 2, 3, 4 ], empty )\n\n    fromList [ 1, 2, 3, 4 ] |> splitAt -1\n    --> ( empty, fromList [ 1, 2, 3, 4 ] )\n\n","type":"Basics.Int -> Array.Array a -> ( Array.Array a, Array.Array a )"},{"name":"unzip","comment":" Split all tuple elements into a tuple of one `Array` with the first and one with the second values.\n\n    import Array exposing (fromList)\n\n    unzip\n        (fromList\n            [ ( 1, 'a' ), ( 2, 'b' ), ( 3, 'c' ) ]\n        )\n    --> ( fromList [ 1, 2, 3 ]\n    --> , fromList [ 'a', 'b', 'c' ]\n    --> )\n\n","type":"Array.Array ( a, b ) -> ( Array.Array a, Array.Array b )"},{"name":"update","comment":" Update the element at a given index based on its current value.\nIf the index is out of bounds, nothing is changed.\n\n    import Array exposing (fromList)\n\n    fromList [ 1, 2, 3 ] |> update 1 (\\n -> n + 10)\n    --> fromList [ 1, 12, 3 ]\n\n    fromList [ 1, 2, 3 ] |> update 4 (\\n -> n + 10)\n    --> fromList [ 1, 2, 3 ]\n\n    fromList [ 1, 2, 3 ] |> update -1 (\\n -> n + 10)\n    --> fromList [ 1, 2, 3 ]\n\n","type":"Basics.Int -> (a -> a) -> Array.Array a -> Array.Array a"},{"name":"zip","comment":" Combine the elements of two `Array`s into tuples.\nIf one is longer, its extra elements are not used.\n\n    import Array exposing (fromList)\n\n    zip\n        (fromList [ 1, 2, 3 ])\n        (fromList [ 'a', 'b' ])\n    --> fromList [ ( 1, 'a' ), ( 2, 'b' ) ]\n\n","type":"Array.Array a -> Array.Array b -> Array.Array ( a, b )"},{"name":"zip3","comment":" Zip the elements of three `Array`s into 3-tuples.\nOnly the indexes of the shortest `Array` are used.\n\n    import Array exposing (fromList)\n\n    zip3\n        (fromList [ 1, 2, 3 ])\n        (fromList [ 'a', 'b' ])\n        (fromList [ \"a\", \"b\", \"c\", \"d\" ])\n    --> fromList\n    -->     [ ( 1, 'a', \"a\" )\n    -->     , ( 2, 'b', \"b\" )\n    -->     ]\n\n","type":"Array.Array a -> Array.Array b -> Array.Array c -> Array.Array ( a, b, c )"}],"binops":[]},{"name":"Basics.Extra","comment":" Additional basic functions.\n\n\n# Numbers\n\n@docs maxSafeInteger, minSafeInteger, isSafeInteger\n\n\n# Math\n\n@docs safeDivide, safeIntegerDivide\n@docs safeModBy, safeRemainderBy\n\n\n# Angles\n\n@docs inDegrees, inRadians, inTurns\n\n\n# Higher-Order Helpers\n\n@docs flip, curry, uncurry\n\n","unions":[],"aliases":[],"values":[{"name":"curry","comment":" Change how arguments are passed to a function.\nThis splits paired arguments into two separate arguments.\n","type":"(( a, b ) -> c) -> a -> b -> c"},{"name":"flip","comment":" Flip the order of the first two arguments to a function.\n","type":"(a -> b -> c) -> b -> a -> c"},{"name":"inDegrees","comment":" Convert standard Elm angles (radians) to degrees.\n\n    inDegrees (turns 2) --> 720\n\n    inDegrees pi --> 180\n\n","type":"Basics.Float -> Basics.Float"},{"name":"inRadians","comment":" Convert standard Elm angles (radians) to radians.\n\n    inRadians (degrees 90) == pi / 2\n\n    inRadians (turns 1) == 2 * pi\n\n","type":"Basics.Float -> Basics.Float"},{"name":"inTurns","comment":" Convert standard Elm angles (radians) to turns. One turn is equal to 360°.\n\n    inTurns (degrees 180) == 0.5\n\n    inTurns (3 * pi) == 1.5\n\n","type":"Basics.Float -> Basics.Float"},{"name":"isSafeInteger","comment":" Checks if a given integer is within the safe range, meaning it is between\n`-(2^53 - 1)` and `2^53 - 1`.\n\n    isSafeInteger 5 --> True\n\n    isSafeInteger maxSafeInteger --> True\n\n    isSafeInteger (maxSafeInteger + 1) --> False\n\n","type":"Basics.Int -> Basics.Bool"},{"name":"maxSafeInteger","comment":" The maximum _safe_ value for an integer, defined as `2^53 - 1`. Anything\nlarger than that and behaviour becomes mathematically unsound.\n\n    maxSafeInteger + 1 --> maxSafeInteger + 2\n\n","type":"number"},{"name":"minSafeInteger","comment":" The minimum _safe_ value for an integer, defined as `-(2^53 - 1)`. Anything\nsmaller than that, and behaviour becomes mathematically unsound.\n\n    minSafeInteger - 1 --> minSafeInteger - 2\n\n","type":"number"},{"name":"safeDivide","comment":" Perform floating-point division (like Elm's `/` operator) that will never\ncrash the app. If the `y` argument in `safeDivide x y` is zero, we return `Nothing`.\n\n    safeDivide 5 2 --> Just 2.5\n\n    -- the interesting part\n    safeDivide 5 0 --> Nothing\n\n","type":"Basics.Float -> Basics.Float -> Maybe.Maybe Basics.Float"},{"name":"safeIntegerDivide","comment":" Perform integer division (like Elm's `//` operator) that will never crash\nthe app. If the `y` argument in `safeIntegerDivide x y` is zero, we return `Nothing`.\n\n    safeIntegerDivide 5 2 --> Just 2\n\n    -- the interesting part\n    safeIntegerDivide 5 0 --> Nothing\n\n","type":"Basics.Int -> Basics.Int -> Maybe.Maybe Basics.Int"},{"name":"safeModBy","comment":" Perform [modular arithmetic][ma] that will never crash the app. If the `modulus`\nargument in `safeModBy modulus x` is zero, we return `Nothing`.\n\n    safeModBy 2 4 --> Just 0\n\n    safeModBy 2 5 --> Just 1\n\n    -- the interesting part\n    safeModBy 0 4 --> Nothing\n\nUse [`safeRemainderBy`](#safeRemainderBy) for a different treatment of negative\nnumbers, or read Daan Leijen’s [Division and Modulus for Computer Scientists][dm]\nfor more information.\n\n[ma]: https://en.wikipedia.org/wiki/Modular_arithmetic\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n\n","type":"Basics.Int -> Basics.Int -> Maybe.Maybe Basics.Int"},{"name":"safeRemainderBy","comment":" Get the remainder after division in a way that will never crash the app. If\nthe `divisor` argument in `safeRemainderBy divisor x` is zero, we return `Nothing`.\n\n    safeRemainderBy 2 4 --> Just 0\n\n    safeRemainderBy 2 5 --> Just 1\n\n    -- the interesting part\n    safeRemainderBy 0 4 --> Nothing\n\nUse [`safeModBy`](#safeModBy) for a different treatment of negative\nnumbers, or read Daan Leijen’s [Division and Modulus for Computer Scientists][dm]\nfor more information.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n\n","type":"Basics.Int -> Basics.Int -> Maybe.Maybe Basics.Int"},{"name":"uncurry","comment":" Change how arguments are passed to a function.\nThis combines two arguments into a single pair.\n","type":"(a -> b -> c) -> ( a, b ) -> c"}],"binops":[]},{"name":"Char.Extra","comment":" Convenience functionality on [`Char`](https://package.elm-lang.org/packages/elm/core/latest/Char)\n\n@docs isSpace, isControl\n\n","unions":[],"aliases":[],"values":[{"name":"isControl","comment":" Returns true if the given character is an ASCII control character.\n","type":"Char.Char -> Basics.Bool"},{"name":"isSpace","comment":" Returns true if the given character is whitespace character.\n","type":"Char.Char -> Basics.Bool"}],"binops":[]},{"name":"Cmd.Extra","comment":" Extra functions for working with Cmds.\n\n\n# Constructors\n\n@docs perform, attempt, maybe, fromResult, fromMaybe\n\n\n# Chaining in update\n\n@docs pure, with, add, withTrigger, addTrigger, addIf, addTriggerMaybe, addMaybe\n\n","unions":[],"aliases":[],"values":[{"name":"add","comment":" Add new cmd to an existing pair.\n","type":"Platform.Cmd.Cmd msg -> ( model, Platform.Cmd.Cmd msg ) -> ( model, Platform.Cmd.Cmd msg )"},{"name":"addIf","comment":" Add new cmd to an existing pair under a certain condition.\n\n    prevCmd : Cmd String\n    prevCmd =\n        perform \"foo\"\n\n    newCmd : Cmd String\n    newCmd =\n        perform \"bar\"\n\n    ( \"model\", prevCmd )\n      |> addIf False newCmd\n      |> Tuple.second\n      |> ((==) prevCmd)\n    --> True\n\n","type":"Basics.Bool -> Platform.Cmd.Cmd msg -> ( model, Platform.Cmd.Cmd msg ) -> ( model, Platform.Cmd.Cmd msg )"},{"name":"addMaybe","comment":" Add new cmd to an existing pair based on the Maybe value\n\n    prevCmd : Cmd String\n    prevCmd =\n        perform \"prev\"\n\n    ( \"model\", prevCmd )\n      |> addMaybe identity Nothing\n      |> Tuple.second\n      |> ((==) prevCmd)\n    --> True\n\n","type":"(a -> Platform.Cmd.Cmd msg) -> Maybe.Maybe a -> ( model, Platform.Cmd.Cmd msg ) -> ( model, Platform.Cmd.Cmd msg )"},{"name":"addTrigger","comment":" Add new trigger of Msg to an existing pair.\n","type":"msg -> ( model, Platform.Cmd.Cmd msg ) -> ( model, Platform.Cmd.Cmd msg )"},{"name":"addTriggerMaybe","comment":" `addTrigger` if Just, do nothing if Nothing\n","type":"Maybe.Maybe msg -> ( model, Platform.Cmd.Cmd msg ) -> ( model, Platform.Cmd.Cmd msg )"},{"name":"attempt","comment":" Similar to perform but takes `Result msg` and performs action only on `Ok`.\n\n    attempted : Cmd String\n    attempted =\n      attempt <| Ok \"I'm fine\"\n\n    attempt (Err \"Failed\") == Cmd.none\n    --> True\n\n","type":"Result.Result x msg -> Platform.Cmd.Cmd msg"},{"name":"fromMaybe","comment":" Construct from Maybe.\n\n    maybeCmd : Cmd (Maybe Int)\n    maybeCmd =\n      identity (Just 1)\n\n    fromMaybe identity Nothing\n    --> Cmd.none\n\n","type":"(a -> msg) -> Maybe.Maybe a -> Platform.Cmd.Cmd msg"},{"name":"fromResult","comment":" Construct from Result.\n\n    resultCmd : Cmd (Result Never Int)\n    resultCmd =\n      fromResult identity (Ok 1)\n\n    fromResult identity (Err ())\n    --> Cmd.none\n\n","type":"(a -> msg) -> Result.Result x a -> Platform.Cmd.Cmd msg"},{"name":"maybe","comment":" Similar to attempt but works with `Maybe` instead\n\n    maybeCmd : Cmd Int\n    maybeCmd =\n        maybe <| Just 1\n\n    maybe Nothing == Cmd.none\n    --> True\n\n","type":"Maybe.Maybe msg -> Platform.Cmd.Cmd msg"},{"name":"perform","comment":" Cmd costructor.\nUseful when you want to artificially emit Cmd from update function.\n\n    performed : Cmd String\n    performed =\n        perform \"foo\"\n\n\"real world\" example:\n\n    type alias Model =\n        ()\n\n    type Msg\n        = Fire\n        | FireRockets\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg () =\n        case msg of\n            Fire ->\n                ( (), perform FireRockets )\n\n            FireRockets ->\n                Debug.crash \"World ended:(\"\n\n","type":"msg -> Platform.Cmd.Cmd msg"},{"name":"pure","comment":" Creates pair `model` with `Cmd.none`\n\n    pair : ( String, Cmd msg )\n    pair = pure \"foo\"\n\n    pair\n      |> Tuple.second\n      |> ((==) Cmd.none)\n    --> True\n\n","type":"model -> ( model, Platform.Cmd.Cmd msg )"},{"name":"with","comment":" Add Cmd to model to create a pair.\n","type":"Platform.Cmd.Cmd msg -> model -> ( model, Platform.Cmd.Cmd msg )"},{"name":"withTrigger","comment":" Trigger Cmd from Msg and create a pair\n","type":"msg -> model -> ( model, Platform.Cmd.Cmd msg )"}],"binops":[]},{"name":"Dict.Extra","comment":" Convenience functions for working with `Dict`\n\n\n# List operations\n\n@docs groupBy, filterGroupBy, fromListBy, fromListCombining, fromListByCombining, frequencies\n\n\n# Manipulation\n\n@docs removeWhen, removeMany, keepOnly, insertCombining, mapKeys, filterMap, invert\n\n\n# Predicates\n\n@docs any, all\n\n\n# Search\n\n@docs find\n\n\n# Combine\n\n@docs unionWith\n\n","unions":[],"aliases":[],"values":[{"name":"all","comment":" Determine if all key/value pairs satisfies some test.\n\n    import Dict\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> all (\\_ value -> value == \"Jill\")\n    --> True\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> all (\\key _ -> key == 9)\n    --> False\n\n","type":"(comparable -> a -> Basics.Bool) -> Dict.Dict comparable a -> Basics.Bool"},{"name":"any","comment":" Determine if any key/value pair satisfies some test.\n\n    import Dict\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> any (\\_ value -> value == \"Jill\")\n    --> True\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> any (\\key _ -> key == 5)\n    --> False\n\n","type":"(comparable -> a -> Basics.Bool) -> Dict.Dict comparable a -> Basics.Bool"},{"name":"filterGroupBy","comment":" Takes a key-fn and a list.\nCreates a `Dict` which maps the key to a list of matching elements, skipping elements\nwhere key-fn returns `Nothing`\n\n    import Dict\n\n    filterGroupBy (String.uncons >> Maybe.map Tuple.first) [ \"tree\" , \"\", \"tweet\", \"apple\" , \"leaf\", \"\" ]\n    --> Dict.fromList [ ( 't', [ \"tree\", \"tweet\" ] ), ( 'a', [ \"apple\" ] ), ( 'l', [ \"leaf\" ] ) ]\n\n    filterGroupBy\n        .car\n        [ { name = \"Mary\"\n          , car = Just \"Ford\"\n          }\n        , { name = \"Jack\"\n          , car = Nothing\n          }\n        , { name = \"Jill\"\n          , car = Just \"Tesla\"\n          }\n        , { name = \"John\"\n          , car = Just \"Tesla\"\n          }\n        ]\n    --> Dict.fromList\n    --> [ ( \"Ford\"\n    -->   , [ { name = \"Mary\" , car = Just \"Ford\" } ]\n    -->   )\n    --> , ( \"Tesla\"\n    -->   , [ { name = \"Jill\" , car = Just \"Tesla\" }\n    -->     , { name = \"John\" , car = Just \"Tesla\" }\n    -->     ]\n    -->   )\n    --> ]\n\n","type":"(a -> Maybe.Maybe comparable) -> List.List a -> Dict.Dict comparable (List.List a)"},{"name":"filterMap","comment":" Apply a function that may or may not succeed to all entries in a dictionary,\nbut only keep the successes.\n\n    import Dict\n\n    let\n        isTeen n a =\n            if 13 <= n && n <= 19 then\n                Just <| String.toUpper a\n            else\n                Nothing\n    in\n    Dict.fromList [ ( 5, \"Jack\" ), ( 15, \"Jill\" ), ( 20, \"Jones\" ) ]\n        |> filterMap isTeen\n    --> Dict.fromList [ ( 15, \"JILL\" ) ]\n\n","type":"(comparable -> a -> Maybe.Maybe b) -> Dict.Dict comparable a -> Dict.Dict comparable b"},{"name":"find","comment":" Find the first key/value pair that matches a predicate.\n\n    import Dict\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> find (\\_ value -> value == \"Jill\")\n    --> Just ( 7, \"Jill\" )\n\n    Dict.fromList [ ( 9, \"Jill\" ), ( 7, \"Jill\" ) ]\n        |> find (\\key _ -> key == 5)\n    --> Nothing\n\n","type":"(comparable -> a -> Basics.Bool) -> Dict.Dict comparable a -> Maybe.Maybe ( comparable, a )"},{"name":"frequencies","comment":" Count the number of occurrences for each of the elements in the list.\n\n    import Dict\n\n    frequencies [ \"A\", \"B\", \"C\", \"B\", \"C\", \"B\" ]\n    --> Dict.fromList [ ( \"A\", 1 ), ( \"B\", 3 ), ( \"C\", 2 ) ]\n\n","type":"List.List comparable -> Dict.Dict comparable Basics.Int"},{"name":"fromListBy","comment":" Create a dictionary from a list of values, by passing a function that can get a key from any such value.\nIf the function does not return unique keys, earlier values are discarded.\n\n    import Dict\n\n    fromListBy String.length [ \"tree\" , \"apple\" , \"leaf\" ]\n    --> Dict.fromList [ ( 4, \"leaf\" ), ( 5, \"apple\" ) ]\n\n","type":"(a -> comparable) -> List.List a -> Dict.Dict comparable a"},{"name":"fromListByCombining","comment":" `fromListBy` and `fromListCombining` rolled into one.\n\n    import Dict\n\n    fromListByCombining (\\first second -> first) String.length [ \"tree\" , \"apple\" , \"leaf\" ]\n    --> Dict.fromList [ ( 4, \"tree\" ), ( 5, \"apple\" ) ]\n\n","type":"(a -> a -> a) -> (a -> comparable) -> List.List a -> Dict.Dict comparable a"},{"name":"fromListCombining","comment":" Like `Dict.fromList`, but you provide a way to deal with\nduplicate keys. Create a dictionary from a list of pairs of keys and\nvalues, providing a function that is used to combine multiple values\npaired with the same key.\n\n    import Dict\n\n    fromListCombining\n        (\\a b -> a ++ \" \" ++ b)\n        [ ( \"class\", \"menu\" ), ( \"width\", \"100%\" ), ( \"class\", \"big\" ) ]\n    --> Dict.fromList [ ( \"class\", \"menu big\" ), ( \"width\", \"100%\" ) ]\n\n","type":"(a -> a -> a) -> List.List ( comparable, a ) -> Dict.Dict comparable a"},{"name":"groupBy","comment":" Takes a key-fn and a list.\nCreates a `Dict` which maps the key to a list of matching elements.\n\n    import Dict\n\n    groupBy String.length [ \"tree\" , \"apple\" , \"leaf\" ]\n    --> Dict.fromList [ ( 4, [ \"tree\", \"leaf\" ] ), ( 5, [ \"apple\" ] ) ]\n\n**See also:** [`List.Extra.gatherEqualsBy`](./List-Extra#gatherEqualsBy).\n\n","type":"(a -> comparable) -> List.List a -> Dict.Dict comparable (List.List a)"},{"name":"insertCombining","comment":" Insert an element at the given key, providing a combining\nfunction that used in the case that there is already an\nelement at that key. The combining function is called with\noriginal element and the new element as arguments and\nreturns the element to be inserted.\n\n    import Dict\n\n    Dict.fromList [ ( \"expenses\", 38.25 ), ( \"assets\", 100.85 ) ]\n        |> insertCombining (+) \"expenses\" 2.50\n        |> insertCombining (+) \"liabilities\" -2.50\n    --> Dict.fromList [ ( \"expenses\", 40.75 ), ( \"assets\", 100.85 ), ( \"liabilities\", -2.50 ) ]\n\n","type":"(v -> v -> v) -> comparable -> v -> Dict.Dict comparable v -> Dict.Dict comparable v"},{"name":"invert","comment":" Inverts the keys and values of an array.\n\n    import Dict\n\n    Dict.fromList [ (\"key\", \"value\")  ]\n        |> invert\n    --> Dict.fromList [ ( \"value\", \"key\" ) ]\n\n","type":"Dict.Dict comparable1 comparable2 -> Dict.Dict comparable2 comparable1"},{"name":"keepOnly","comment":" Keep a key-value pair if its key appears in the set.\n\n    import Dict\n    import Set\n\n    Dict.fromList [ ( \"Mary\", 1 ), ( \"Jack\", 2 ), ( \"Jill\", 1 ) ]\n        |> keepOnly (Set.fromList [ \"Jack\", \"Jill\" ])\n    --> Dict.fromList [ ( \"Jack\", 2 ), ( \"Jill\", 1 ) ]\n\n","type":"Set.Set comparable -> Dict.Dict comparable v -> Dict.Dict comparable v"},{"name":"mapKeys","comment":" Apply a function to all keys in a dictionary.\n\n    import Dict\n\n    Dict.fromList [ ( 5, \"Jack\" ), ( 10, \"Jill\" ) ]\n        |> mapKeys (\\x -> x + 1)\n    --> Dict.fromList [ ( 6, \"Jack\" ), ( 11, \"Jill\" ) ]\n\n    Dict.fromList [ ( 5, \"Jack\" ), ( 10, \"Jill\" ) ]\n        |> mapKeys String.fromInt\n    --> Dict.fromList [ ( \"5\", \"Jack\" ), ( \"10\", \"Jill\" ) ]\n\n","type":"(comparable -> comparable1) -> Dict.Dict comparable v -> Dict.Dict comparable1 v"},{"name":"removeMany","comment":" Remove a key-value pair if its key appears in the set.\n\n    import Dict\n    import Set\n\n    Dict.fromList [ ( \"Mary\", 1 ), ( \"Jack\", 2 ), ( \"Jill\", 1 ) ]\n        |> removeMany (Set.fromList [ \"Mary\", \"Jill\" ])\n    --> Dict.fromList [ ( \"Jack\", 2 ) ]\n\n","type":"Set.Set comparable -> Dict.Dict comparable v -> Dict.Dict comparable v"},{"name":"removeWhen","comment":" Remove elements which satisfies the predicate.\n\n    import Dict\n\n    Dict.fromList [ ( \"Mary\", 1 ), ( \"Jack\", 2 ), ( \"Jill\", 1 ) ]\n        |> removeWhen (\\_ value -> value == 1 )\n    --> Dict.fromList [ ( \"Jack\", 2 ) ]\n\n","type":"(comparable -> v -> Basics.Bool) -> Dict.Dict comparable v -> Dict.Dict comparable v"},{"name":"unionWith","comment":" Combine two dictionaries. If there is a collision, a combining function is\nused to combine the two values.\n\n    import Dict\n\n    unionWith (\\k v1 v2 -> String.fromInt k ++ v1 ++ v2 )\n        (Dict.fromList [ ( 1, \"123\" ), ( 2, \"abc\" ) ])\n        (Dict.fromList [ ( 2, \"def\" ), ( 3, \"xyz\" ) ])\n        --> Dict.fromList [ ( 1, \"123\" ), ( 2, \"2abcdef\" ), ( 3, \"xyz\" ) ]\n\nNote that, like `Dict.union`, it is more efficient to have the larger `Dict` as\nthe second argument, i.e. when possible, you should use `unionWith f new old`,\nif `old` has more keys than `new`.\n\n","type":"(comparable -> a -> a -> a) -> Dict.Dict comparable a -> Dict.Dict comparable a -> Dict.Dict comparable a"}],"binops":[]},{"name":"Float.Extra","comment":" Convenience functions for dealing with Floats.\n\n\n# Equality\n\n@docs aboutEqual\n\n\n# Formatting Floats\n\n@docs toFixedDecimalPlaces, toFixedSignificantDigits, boundaryValuesAsUnicode\n\n\n# Ranges\n\n@docs range\n\n\n# Modular arithmetic\n\n@docs modBy\n\n","unions":[],"aliases":[],"values":[{"name":"aboutEqual","comment":" Comparing Floats with `==` is usually wrong, unless you basically care for reference equality, since floating point\nnumbers often have small precision drift.\n\n    0.1 + 0.2 == 0.3 --> False\n\nThis function implements an approximation where we are asking - are these values close enough that we can consider their difference to be\ndue to floating point drift rather than a result of meaningful difference in calculation?\n\n    (0.1 + 0.2) |> Float.Extra.aboutEqual 0.3 --> True\n\nNote: this is unlikely to be appropriate if you are performing computations much smaller than one.\n\n    (0.00001 + 0.00002) |> Float.Extra.aboutEqual 0.00003 --> True\n\nThis value handles Infinity and NaN like so:\n\n    (1 / 0) |> Float.Extra.aboutEqual (100 / 0) --> True\n\n    (0 / 0) |> Float.Extra.aboutEqual (0 / 0) --> False\n\n","type":"Basics.Float -> Basics.Float -> Basics.Bool"},{"name":"boundaryValuesAsUnicode","comment":" When showing Float values to users, we generally don't particularly want them to see programmer-y values like\n`NaN` or `Infinity`. This function wraps a number formatting routine, but replaces those values with unicode symbols:\n\n    format : Float -> String\n    format =\n        Float.Extra.toFixedSignificantDigits 3\n            |> Float.Extra.boundaryValuesAsUnicode\n\n    format (0 / 0) --> \"∅\"\n    format (1 / 0) --> \"∞\"\n    format (-1 / 0) --> \"-∞\"\n    format (1 / 3) -> \"0.333\"\n\nOf course using this is unsuitable for when you want the numbers to be machine readable.\n\n","type":"(Basics.Float -> String.String) -> Basics.Float -> String.String"},{"name":"modBy","comment":" Perform [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic)\ninvolving floating point numbers.\n\nThe sign of the result is the same as the sign of the `modulus`\nin `Float.Extra.modBy modulus x`.\n\n    Float.Extra.modBy 2.5 5 --> 0\n\n    Float.Extra.modBy 2 4.5 == 0.5\n\n    Float.Extra.modBy 2 -4.5 == 1.5\n\n    Float.Extra.modBy -2 4.5 == -1.5\n\n","type":"Basics.Float -> Basics.Float -> Basics.Float"},{"name":"range","comment":" Returns a List containing an arithmetic progression, similar to the Python\nbuilt-in range.\n\nTakes a `start`, `stop` and `step` argument. The stop value is exclusive; it is not\nincluded in the result. If `step` is positive, the last element is the largest\n`start + i * step` less than `stop`; if `step` is negative, the last element is\nthe smallest `start + i * step` greater than `stop`. If the returned list would\ncontain an infinite number of values, an empty range is returned.\n\nThe arguments are not required to be whole numbers; however, the results are more\npredictable if they are.\n\nDifferences from [List.range from the standard library](https://package.elm-lang.org/packages/elm/core/latest/List#range):\n\n  - `List.range` is inclusive, meaning that the stop value will be included in the result\n  - `List.range` supports `Int`, whereas this uses `Float`\n  - `List.range` supports only increasing intervals (i.e. `List.range 3 1 == []` vs. `range 3 1 -1 == [3, 2]`)\n  - `List.range` doesn't allow for specifying the step value\n\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> List.List Basics.Float"},{"name":"toFixedDecimalPlaces","comment":" Fix a float value represented to a certain number of decimal places as a string.\n\n    Float.Extra.toFixedDecimalPlaces 3 0.0326232 --> \"0.033\"\n\n","type":"Basics.Int -> Basics.Float -> String.String"},{"name":"toFixedSignificantDigits","comment":" Fix a float value represented as a string to a certain number of significant digits.\n\n    Float.Extra.toFixedSignificantDigits 2 1.435 --> \"1.4\"\n\n    Float.Extra.toFixedSignificantDigits 2 545435 --> \"550000\"\n\n    Float.Extra.toFixedSignificantDigits 2 0.0039 --> \"0.0039\"\n\n","type":"Basics.Int -> Basics.Float -> String.String"}],"binops":[]},{"name":"List.Extra","comment":" Convenience functions for working with List\n\n\n# Basics\n\n@docs last, init, getAt, cons, uncons, unconsLast, maximumBy, maximumWith, minimumBy, minimumWith, andMap, andThen, reverseMap, takeWhile, dropWhile, unique, uniqueBy, allDifferent, allDifferentBy, setIf, setAt, remove, updateIf, updateAt, updateIfIndex, removeAt, removeIfIndex, removeWhen, swapAt, stableSortWith\n\n\n# List transformations\n\n@docs intercalate, transpose, subsequences, permutations, interweave, cartesianProduct, uniquePairs\n\n\n# Folds\n\n@docs foldl1, foldr1, indexedFoldl, indexedFoldr, Step, stoppableFoldl\n\n\n# Building lists\n\n@docs scanl, scanl1, scanr, scanr1, mapAccuml, mapAccumr, unfoldr, iterate, initialize, cycle, reverseRange\n\n\n# Sublists\n\n@docs splitAt, splitWhen, takeWhileRight, dropWhileRight, span, break, stripPrefix, group, groupWhile, inits, tails, conditional, select, selectSplit, gatherEquals, gatherEqualsBy, gatherWith, subsequencesNonEmpty, frequencies\n\n\n# Predicates\n\n@docs isPrefixOf, isSuffixOf, isInfixOf, isSubsequenceOf, isPermutationOf\n\n\n# Searching\n\n@docs notMember, find, elemIndex, elemIndices, findIndex, findIndices, findMap, count\n\n\n# Zipping\n\n@docs zip, zip3\n\n\n# Lift functions onto multiple lists of arguments\n\n@docs lift2, lift3, lift4\n\n\n# Split to groups of given size\n\n@docs groupsOf, groupsOfWithStep, groupsOfVarying, greedyGroupsOf, greedyGroupsOfWithStep\n\n\n# Joins\n\n@docs joinOn\n\n","unions":[{"name":"Step","comment":" A custom type used for stoppable folds.\n","args":["a"],"cases":[["Continue",["a"]],["Stop",["a"]]]}],"aliases":[],"values":[{"name":"allDifferent","comment":" Indicate if list has duplicate values.\n\n    allDifferent [ 0, 1, 1, 0, 1 ]\n    --> False\n\n    allDifferent [ 0, 1, 2]\n    --> True\n\n","type":"List.List a -> Basics.Bool"},{"name":"allDifferentBy","comment":" Indicate if list has duplicate values when supplied function are applied on each values.\n","type":"(a -> b) -> List.List a -> Basics.Bool"},{"name":"andMap","comment":" Map functions taking multiple arguments over multiple lists. Each list should be of the same length.\n\n    toIntFunctions : List (Float -> Int)\n    toIntFunctions =\n        [ round\n        , floor\n        , ceiling\n        , truncate\n        ]\n\n    toIntFunctions\n        |> andMap [ -1.5, -1.5, -1.5, -1.5 ]\n        --> [ -1, -2, -1, -1 ]\n\n\n    math : List (Int -> Int)\n    math =\n        [ (+) 1\n        , (*) 2\n        , (*) 3 >> (+) 1\n        ]\n\n    math\n        |> andMap [ 1, 2, 3 ]\n        --> [ 2, 4, 10 ]\n\n","type":"List.List a -> List.List (a -> b) -> List.List b"},{"name":"andThen","comment":" Equivalent to `concatMap`. For example, suppose you want to have a cartesian product of [1,2] and [3,4]:\n\n    [ 1, 2 ]\n        |> andThen\n            (\\x ->\n                [ 3, 4 ]\n                    |> andThen (\\y -> [ ( x, y ) ])\n            )\n        --> [ ( 1, 3 ), ( 1, 4 ), ( 2, 3 ), ( 2, 4 ) ]\n\nNow suppose we want to have a cartesian product between the first list and the second list and its doubles:\n\n    [ 1, 2 ]\n        |> andThen\n            (\\x ->\n                [ 3, 4 ]\n                    |> andThen\n                        (\\y ->\n                            [ y, y * 2 ]\n                                |> andThen (\\z -> [ ( x, z ) ])\n                        )\n            )\n        --> [ ( 1, 3 ), ( 1, 6 ), ( 1, 4 ), ( 1, 8 ), ( 2, 3 ), ( 2, 6 ), ( 2, 4 ), ( 2, 8 )]\n\nAdvanced functional programmers will recognize this as the implementation of bind operator (>>=) for lists from the `Monad` typeclass.\n\n","type":"(a -> List.List b) -> List.List a -> List.List b"},{"name":"break","comment":" Take a predicate and a list, return a tuple. The first part of the tuple is the longest prefix of that list, for each element of which the predicate _does not_ hold. The second part of the tuple is the remainder of the list. `break p xs` is equivalent to `(takeWhile (not p) xs, dropWhile (not p) xs)`.\n\n    break ((<) 3) [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n    --> ( [ 1, 2, 3 ], [ 4, 1, 2, 3, 4 ] )\n\n    break ((>) 5) [ 1, 2, 3 ]\n    --> ( [], [ 1, 2, 3 ] )\n\n    break ((<) 5) [ 1, 2, 3 ]\n    --> ( [ 1, 2, 3 ], [] )\n\n","type":"(a -> Basics.Bool) -> List.List a -> ( List.List a, List.List a )"},{"name":"cartesianProduct","comment":" Return the cartesian product of a list of lists.\nIf one list is empty, the result is an empty list.\nIf the list of lists is empty, the result is an empty singleton.\n\n    cartesianProduct [ [ 1, 2 ], [ 3, 4, 5 ], [ 6 ] ]\n    --> [ [ 1, 3, 6 ], [ 1, 4, 6 ], [ 1, 5, 6 ], [ 2, 3, 6 ], [ 2, 4, 6 ], [ 2, 5, 6 ] ]\n\n    cartesianProduct [ [ 1, 2 ] ]\n    --> [ [ 1 ], [ 2 ] ]\n\n    cartesianProduct [ [ 1, 2 ], [], [ 6 ] ]\n    --> []\n\n    cartesianProduct [ [] ]\n    --> []\n\n    cartesianProduct []\n    --> [ [] ]\n\n","type":"List.List (List.List a) -> List.List (List.List a)"},{"name":"conditional","comment":" Primary useful with literals in view style code.\n\nSometimes you want to include attributes conditionally:\n\n    Html.div\n        ((if isStylish then\n            [ Html.Attributes.class \"foo\" ]\n\n          else\n            [ Html.Attributes.id \"bar\" ]\n         )\n            ++ (if isFancy then\n                    [ Html.Attribute.attribute \"aria-description\" \"A very fancy div\" ]\n\n                else\n                    []\n               )\n        )\n        [ Html.text \"Hello\" ]\n\nBut this is quite awkward and verbose. But with this helper you can write:\n\n    Html.div\n        (List.Extra.conditional\n            [ ( Html.Attributes.class \"foo\", isStylish )\n            , ( Html.Attributes.id \"bar\", not isStylish )\n            , ( Html.Attribute.attribute \"aria-description\" \"A very fancy div\", isFancy )\n            ]\n        )\n        [ Html.text \"Hello\" ]\n\n","type":"List.List ( a, Basics.Bool ) -> List.List a"},{"name":"cons","comment":" Adds the first element of the tuple to the head of the list.\n\n    cons (1, [2, 3])\n    --> [1, 2, 3]\n\nUseful for dealing with non-empty lists such as produced by `group` and `groupWhile`.\n\n","type":"( a, List.List a ) -> List.List a"},{"name":"count","comment":" Returns the number of elements in a list that satisfy a given predicate.\nEquivalent to `List.length (List.filter pred list)` but more efficient.\n\n    count\n        (modBy 2 >> (==) 1) [ 1, 2, 3, 4, 5, 6, 7 ]\n    --> 4\n\n    count\n        ((==) \"yeah\")\n        [ \"She\", \"loves\", \"you\", \"yeah\", \"yeah\", \"yeah\" ]\n    --> 3\n\n","type":"(a -> Basics.Bool) -> List.List a -> Basics.Int"},{"name":"cycle","comment":" Creates a list of the given length whose elements are obtained by cycling\nthrough the elements of the given list. If the given list is empty, the\nresulting list will be empty.\n\n    cycle 6 [ 4, 7, 8 ]\n    --> [ 4, 7, 8, 4, 7, 8 ]\n\n    cycle 4 [ 'a', 'b', 'c' ]\n    --> [ 'a', 'b', 'c', 'a' ]\n\n    cycle 9001 []\n    --> []\n\n    cycle 2 [ 1, 2, 3, 4, 5 ]\n    --> [ 1, 2 ]\n\n","type":"Basics.Int -> List.List a -> List.List a"},{"name":"dropWhile","comment":" Drop elements in order as long as the predicate evaluates to `True`\n","type":"(a -> Basics.Bool) -> List.List a -> List.List a"},{"name":"dropWhileRight","comment":" Drop elements from the right, while predicate still holds.\n\n    dropWhileRight ((<) 5) (List.range 1 10)\n    --> [ 1, 2, 3, 4, 5 ]\n\n","type":"(a -> Basics.Bool) -> List.List a -> List.List a"},{"name":"elemIndex","comment":" Return the index of the first occurrence of the element. Otherwise, return `Nothing`. Indexing starts from 0.\n\n    elemIndex 1 [ 1, 2, 3 ]\n    --> Just 0\n\n    elemIndex 4 [ 1, 2, 3 ]\n    --> Nothing\n\n    elemIndex 1 [ 1, 2, 1 ]\n    --> Just 0\n\n","type":"a -> List.List a -> Maybe.Maybe Basics.Int"},{"name":"elemIndices","comment":" Return all indices of occurrences of the element. If element is not found, return empty list. Indexing starts from 0.\n\n    elemIndices 1 [ 1, 2, 3 ]\n    --> [ 0 ]\n\n    elemIndices 4 [ 1, 2, 3 ]\n    --> []\n\n    elemIndices 1 [ 1, 2, 1 ]\n    --> [ 0, 2 ]\n\n","type":"a -> List.List a -> List.List Basics.Int"},{"name":"find","comment":" Find the first element that satisfies a predicate and return\nJust that element. If none match, return Nothing.\n\n    find (\\num -> num > 5) [ 2, 4, 6, 8 ]\n    --> Just 6\n\n","type":"(a -> Basics.Bool) -> List.List a -> Maybe.Maybe a"},{"name":"findIndex","comment":" Take a predicate and a list, return the index of the first element that satisfies the predicate. Otherwise, return `Nothing`. Indexing starts from 0.\n\n    isEven : Int -> Bool\n    isEven i =\n        modBy 2 i == 0\n\n    findIndex isEven [ 1, 2, 3 ]\n    --> Just 1\n\n    findIndex isEven [ 1, 3, 5 ]\n    --> Nothing\n\n    findIndex isEven [ 1, 2, 4 ]\n    --> Just 1\n\n","type":"(a -> Basics.Bool) -> List.List a -> Maybe.Maybe Basics.Int"},{"name":"findIndices","comment":" Take a predicate and a list, return indices of all elements satisfying the predicate. Otherwise, return empty list. Indexing starts from 0.\n\n    isEven : Int -> Bool\n    isEven i =\n        modBy 2 i == 0\n\n    findIndices isEven [ 1, 2, 3 ]\n    --> [ 1 ]\n\n    findIndices isEven [ 1, 3, 5 ]\n    --> []\n\n    findIndices isEven [ 1, 2, 4 ]\n    --> [ 1, 2 ]\n\n","type":"(a -> Basics.Bool) -> List.List a -> List.List Basics.Int"},{"name":"findMap","comment":" Apply a function that may succeed to values in the list and return the result of the first successful match. If none match, then return Nothing.\n\n    mapOverFive : Int -> Maybe Int\n    mapOverFive num =\n        if num > 5 then\n            Just (num * 2)\n        else\n            Nothing\n\n    findMap mapOverFive [2, 4, 6, 8]\n    --> Just 12\n\nThis is particularly useful in cases where you have a complex type in a list, and you need to pick out the the first one\n\n    type alias HouseModel =\n        {}\n\n    type Property\n        = Rental\n        | House HouseModel\n        | Commercial\n\n    toHouse : Property -> Maybe HouseModel\n    toHouse property =\n        case property of\n            House house ->\n                Just house\n\n            _ ->\n                Nothing\n\n    viewFirstHomeOfInterest : Viewer -> List Property -> Html msg\n    viewFirstHomeOfInterest viewer propertiesQuery =\n        propertiesQuery\n            |> findMap toHouse\n            |> Maybe.map homeView\n            |> Maybe.withDefault noHomeView\n\n","type":"(a -> Maybe.Maybe b) -> List.List a -> Maybe.Maybe b"},{"name":"foldl1","comment":" Variant of `foldl` that has no starting value argument and treats the head of the list as its starting value. If the list is empty, return `Nothing`.\n\n    foldl1 (-) [ 1, 2, 3, 4 ]\n    --> Just 2\n\n    foldl1 (++) [ \"a\", \"b\", \"c\" ]\n    --> Just \"cba\"\n\n    foldl1 min []\n    --> Nothing\n\n**Note:** This function changed in a major way between version 7.0.0 and 8.0.0 of this package. The function `foldl1` took in 7.0.0 was `b -> a -> b` consistent with the Haskell implementation of `foldl`, but now its `a -> b -> b`, consistent with `List.foldl`. This function behaves differently in a breaking way, even though its type signature is the same.\n\n","type":"(a -> a -> a) -> List.List a -> Maybe.Maybe a"},{"name":"foldr1","comment":" Variant of `foldr` that has no starting value argument and treats the last element of the list as its starting value. If the list is empty, return `Nothing`.\n\n    foldr1 (-) [ 1, 2, 3, 4 ]\n    --> Just -2\n\n    foldr1 (++) [ \"a\", \"b\", \"c\" ]\n    --> Just \"abc\"\n\n    foldr1 min []\n    --> Nothing\n\n","type":"(a -> a -> a) -> List.List a -> Maybe.Maybe a"},{"name":"frequencies","comment":" Calculate the number of occurences for each element in a list. Elements\nwill be ordered ascendingly, then grouped in a tuple with the number of\noccurences.\n\n    frequencies [2,1,3,2,3,3]\n    --> [(1,1),(2,2),(3,3)]\n\n","type":"List.List comparable -> List.List ( comparable, Basics.Int )"},{"name":"gatherEquals","comment":" Group equal elements together. This is different from `group` as each sublist\nwill contain _all_ equal elements of the original list. Elements will be grouped\nin the same order as they appear in the original list. The same applies to elements\nwithin each group.\n\n    gatherEquals [1,2,1,3,2]\n    --> [(1,[1]),(2,[2]),(3,[])]\n\n","type":"List.List a -> List.List ( a, List.List a )"},{"name":"gatherEqualsBy","comment":" Group equal elements together. A function is applied to each element of the list\nand then the equality check is performed against the results of that function evaluation.\nElements will be grouped in the same order as they appear in the original list. The\nsame applies to elements within each group.\n\n    gatherEqualsBy .age [{age=25},{age=23},{age=25}]\n    --> [({age=25},[{age=25}]),({age=23},[])]\n\n**See also:** [`Dict.Extra.groupBy`](./Dict-Extra#groupBy).\n\n","type":"(a -> b) -> List.List a -> List.List ( a, List.List a )"},{"name":"gatherWith","comment":" Group equal elements together using a custom equality function. Elements will be\ngrouped in the same order as they appear in the original list. The same applies to\nelements within each group.\n\n    gatherWith (==) [1,2,1,3,2]\n    --> [(1,[1]),(2,[2]),(3,[])]\n\n","type":"(a -> a -> Basics.Bool) -> List.List a -> List.List ( a, List.List a )"},{"name":"getAt","comment":" Returns `Just` the element at the given index in the list,\nor `Nothing` if the index is out of range.\n","type":"Basics.Int -> List.List a -> Maybe.Maybe a"},{"name":"greedyGroupsOf","comment":" Greedily split list into groups of length `size`. The last group of\nelements will be included regardless of whether there are enough elements in\nthe list to completely fill it. This is equivalent to calling\n`greedyGroupsOfWithStep` with the same `size` and `step`.\n\n    greedyGroupsOf 3 (List.range 1 10)\n    --> [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 10 ] ]\n\n","type":"Basics.Int -> List.List a -> List.List (List.List a)"},{"name":"greedyGroupsOfWithStep","comment":" Greedily split list into groups of length `size` at offsets `step` apart.\nThe last group of elements will be included regardless of whether there are\nenough elements in the list to completely fill it. (See `groupsOfWithStep`\nfor the non-greedy version of this function).\n\n    greedyGroupsOfWithStep 4 4 (List.range 1 10)\n    --> [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ], [ 9, 10 ] ]\n\n    greedyGroupsOfWithStep 3 2 (List.range 1 6)\n    --> [ [ 1, 2, 3 ], [ 3, 4, 5 ], [ 5, 6 ] ]\n\n    greedyGroupsOfWithStep 3 6 (List.range 1 20)\n    --> [ [ 1, 2, 3 ], [ 7, 8, 9 ], [ 13, 14, 15 ], [ 19, 20 ] ]\n\nIf `step == size`, every element will appear in exactly one group. If\n`step < size`, there will be an overlap between groups. If `step > size`, some\nelements will be skipped and not appear in any groups.\n\n","type":"Basics.Int -> Basics.Int -> List.List a -> List.List (List.List a)"},{"name":"group","comment":" Group similar elements together. `group` is equivalent to `groupWhile (==)`.\n\n    group [ 1, 2, 2, 3, 3, 3, 2, 2, 1 ]\n    --> [ (1, []), (2, [ 2 ]), (3, [ 3, 3 ]), (2, [ 2 ]), ( 1,  []) ]\n\n","type":"List.List a -> List.List ( a, List.List a )"},{"name":"groupWhile","comment":" Group elements together, using a custom comparison test (`a -> a -> Bool`). Start a new group each time the comparison test doesn't hold for two adjacent elements.\n\n`groupWhile` uses a non-empty list type `(a, List a)` since groups necessarily must have at least one member since they are determined by comparing two members.\n\n    groupWhile\n        (==)\n        [ 1, 2, 3 ]\n    --> [ ( 1, [] ), ( 2, [] ), ( 3, [] ) ]\n\n    groupWhile\n        (<)\n        [ 1, 2, 3, 2, 4, 1, 3, 2, 1 ]\n    --> [ ( 1, [ 2, 3 ] ), ( 2, [ 4 ] ), ( 1, [ 3 ] ), ( 2, [] ), ( 1, [] ) ]\n\n    groupWhile\n        (\\a b -> a.id == b.id)\n        [ { value = 4, id = 9 }, { value = 7, id = 2 }, { value = 1, id = 2 } ]\n    --> [ ( { value = 4, id = 9 }, [] ), ( { value = 7, id = 2 }, [ { value = 1, id = 2 } ] ) ]\n\n**Note:**\nThe behavior of this function has changed between major versions 7 and 8. In version 7 there was `groupWhile` and `groupWhileTransitively`. The behavior of the two was almost identical, however the transitive function was closer to what users found intuitive about grouping. `groupWhileTransitively` has been deleted, and `groupWhile` has been replaced with the version 7s `groupWhileTransitively` behavior. Furthermore the group type was changed from `List a` to the non-empty list type `(a, List a)`. Sorry for any inconvenience this may cause.\n\n","type":"(a -> a -> Basics.Bool) -> List.List a -> List.List ( a, List.List a )"},{"name":"groupsOf","comment":" Split list into groups of length `size`. If there are not enough elements\nto completely fill the last group, it will not be included. This is equivalent\nto calling `groupsOfWithStep` with the same `size` and `step`.\n\n    groupsOf 3 (List.range 1 10)\n    --> [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\n\n","type":"Basics.Int -> List.List a -> List.List (List.List a)"},{"name":"groupsOfVarying","comment":" `groupsOfVarying ns` takes `n` elements from a list for each `n` in `ns`, splitting the list into variably sized segments\n\n    groupsOfVarying [ 2, 3, 1 ] [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ]\n    --> [ [ \"a\", \"b\" ], [ \"c\", \"d\", \"e\" ], [ \"f\" ] ]\n\n    groupsOfVarying [ 2 ] [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ]\n    --> [ [ \"a\", \"b\" ] ]\n\n    groupsOfVarying [ 2, 3, 1, 5, 6 ] [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n    --> [ [ \"a\", \"b\" ], [ \"c\", \"d\", \"e\" ] ]\n\n","type":"List.List Basics.Int -> List.List a -> List.List (List.List a)"},{"name":"groupsOfWithStep","comment":" Split list into groups of length `size` at offsets `step` apart. If there\nare not enough elements to completely fill the last group, it will not be\nincluded. (See `greedyGroupsOfWithStep` if you would like the last group to be\nincluded regardless.)\n\n    groupsOfWithStep 4 4 (List.range 1 10)\n    --> [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ]\n\n    groupsOfWithStep 3 1 (List.range 1 5)\n    --> [ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4, 5 ] ]\n\n    groupsOfWithStep 3 6 (List.range 1 20)\n    --> [ [ 1, 2, 3 ], [ 7, 8, 9 ], [ 13, 14, 15 ] ]\n\nIf `step == size`, every element (except for perhaps the last few due to the\nnon-greedy behavior) will appear in exactly one group. If `step < size`, there\nwill be an overlap between groups. If `step > size`, some elements will be\nskipped and not appear in any groups.\n\n","type":"Basics.Int -> Basics.Int -> List.List a -> List.List (List.List a)"},{"name":"indexedFoldl","comment":" Variant of `foldl` that passes the index of the current element to the step function. `indexedFoldl` is to `List.foldl` as `List.indexedMap` is to `List.map`.\n","type":"(Basics.Int -> a -> b -> b) -> b -> List.List a -> b"},{"name":"indexedFoldr","comment":" Variant of `foldr` that passes the index of the current element to the step function. `indexedFoldr` is to `List.foldr` as `List.indexedMap` is to `List.map`.\n","type":"(Basics.Int -> a -> b -> b) -> b -> List.List a -> b"},{"name":"init","comment":" Return all elements of the list except the last one.\n\n    init [ 1, 2, 3 ]\n    --> Just [ 1, 2 ]\n\n    init []\n    --> Nothing\n\n","type":"List.List a -> Maybe.Maybe (List.List a)"},{"name":"initialize","comment":" Initialize a list of some length with some function.\n\n`initialize n f` creates a list of length `n` with the element at index `i` initialized to the result of `f i`.\n\n","type":"Basics.Int -> (Basics.Int -> a) -> List.List a"},{"name":"inits","comment":" Return all initial segments of a list, from shortest to longest, empty list first, the list itself last.\n\n    inits [ 1, 2, 3 ]\n    --> [ [], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ] ]\n\n","type":"List.List a -> List.List (List.List a)"},{"name":"intercalate","comment":" Take a list and a list of lists, insert that list between every list in the list of lists, concatenate the result. `intercalate xs xss` is equivalent to `concat (intersperse xs xss)`.\n\n    intercalate [ 0, 0 ] [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]\n    --> [ 1, 2, 0, 0, 3, 4, 0, 0, 5, 6 ]\n\n","type":"List.List a -> List.List (List.List a) -> List.List a"},{"name":"interweave","comment":" Return a list that contains elements from the two provided, in alternate order.\nIf one list runs out of items, append the items from the remaining list.\n\n    interweave [ 1, 3 ] [ 2, 4 ]\n    --> [ 1, 2, 3, 4 ]\n\n    interweave [ 1, 3, 5, 7 ] [ 2, 4 ]\n    --> [ 1, 2, 3, 4, 5, 7 ]\n\n    interweave [ 4, 9, 16 ] [ 2, 3, 5, 7 ]\n    --> [ 4, 2, 9, 3, 16, 5, 7 ]\n\n","type":"List.List a -> List.List a -> List.List a"},{"name":"isInfixOf","comment":" Return True if all the elements of the first list occur in-order and\nconsecutively anywhere within the second.\n\n    isInfixOf [ 5, 7, 11 ] [ 2, 3, 5, 7, 11, 13 ]\n    --> True\n\n    isInfixOf [ 5, 7, 13 ] [ 2, 3, 5, 7, 11, 13 ]\n    --> False\n\n    isInfixOf [ 3, 5, 2 ] [ 2, 3, 5, 7, 11, 13 ]\n    --> False\n\n","type":"List.List a -> List.List a -> Basics.Bool"},{"name":"isPermutationOf","comment":" Take two lists and return `True`, if the first list is a permutation of the second list.\nIn other words: Do the 2 `List`s contain the same elements but in a different order?\n\n    [ 3, 1, 2 ]\n        |> isPermutationOf\n            [ 1, 2, 3 ]\n    --> True\n\n    [ 3, 1, 0 ]\n        |> isPermutationOf\n            [ 1, 2, 3 ]\n    --> False\n\n    [ 3, 1, 2, 2 ]\n        |> isPermutationOf\n            [ 1, 2, 3 ]\n    --> False\n\n","type":"List.List a -> List.List a -> Basics.Bool"},{"name":"isPrefixOf","comment":" Take two lists and return `True`, if the first list is the prefix of the second list.\n","type":"List.List a -> List.List a -> Basics.Bool"},{"name":"isSubsequenceOf","comment":" Return True if all the elements of the first list occur, in order, in the\nsecond. The elements do not have to occur consecutively.\n\n    isSubsequenceOf\n        [ \"E\", \"l\", \"m\" ]\n        [ \"E\", \"a\", \"t\", \" \", \"l\", \"i\", \"m\", \"e\", \"s\" ]\n    --> True\n\n    isSubsequenceOf\n        [ \"E\", \"l\", \"m\" ]\n        [ \"E\", \"m\", \"a\", \"i\", \"l\" ]\n    --> False\n\n","type":"List.List a -> List.List a -> Basics.Bool"},{"name":"isSuffixOf","comment":" Take two lists and return `True`, if the first list is the suffix of the second list.\n","type":"List.List a -> List.List a -> Basics.Bool"},{"name":"iterate","comment":" Returns a list of repeated applications of `f`. If `f` returns `Nothing`\nthe iteration will stop. If it returns `Just y` then `y` will be added to the\nlist and the iteration will continue with `f y`.\n\n    collatz : Int -> Maybe Int\n    collatz n =\n        if n == 1 then\n            Nothing\n        else\n            Just <|\n                if modBy 2 n == 0 then\n                    n // 2\n                else\n                    3 * n + 1\n\n    iterate collatz 13\n    --> [13,40,20,10,5,16,8,4,2,1]\n\n","type":"(a -> Maybe.Maybe a) -> a -> List.List a"},{"name":"joinOn","comment":" Performs an inner join, combining data items from both lists if they match by their respective key functions.\n\n    employees : List { name : String, departmentId : Int }\n    employees =\n        [ { name = \"Rafferty\", departmentId = 31 }\n        , { name = \"Jones\", departmentId = 33 }\n        , { name = \"Heisenberg\", departmentId = 33 }\n        , { name = \"Robinson\", departmentId = 34 }\n        , { name = \"Smith\", departmentId = 34 }\n        ]\n\n    departments : List { name : String, departmentId : Int }\n    departments =\n        [ { departmentId = 31, name = \"Sales\" }\n        , { departmentId = 33, name = \"Engineering\" }\n        , { departmentId = 34, name = \"Clerical\" }\n        , { departmentId = 35, name = \"Marketing\" }\n        ]\n\n    joinOn (\\empl dep -> { employee = empl.name, department = dep.name}) .departmentId .departmentId employees departments\n    --> [ { department = \"Clerical\", employee = \"Robinson\" }\n    --> , { department = \"Clerical\", employee = \"Smith\" }\n    --> , { department = \"Engineering\", employee = \"Jones\" }\n    --> , { department = \"Engineering\", employee = \"Heisenberg\" }\n    --> , { department = \"Sales\", employee = \"Rafferty\" }\n    --> ]\n\nThis is akin to the SQL query:\n\n    SELECT employee.name, department.name\n    FROM employee\n    INNER JOIN department\n    ON employee.departmentId = department.departmentId\n\n","type":"(a -> b -> c) -> (a -> comparable) -> (b -> comparable) -> List.List a -> List.List b -> List.List c"},{"name":"last","comment":" Extract the last element of a list.\n\n    last [ 1, 2, 3 ]\n    --> Just 3\n\n    last []\n    --> Nothing\n\n","type":"List.List a -> Maybe.Maybe a"},{"name":"lift2","comment":" Map functions taking multiple arguments over multiple lists, regardless of list length.\nAll possible combinations will be explored.\n\n    lift2 (+) [1,2,3][4,5]\n    --> [5,6,6,7,7,8]\n\n","type":"(a -> b -> c) -> List.List a -> List.List b -> List.List c"},{"name":"lift3","comment":" Maps a function over three lists, exploring all possible combinations.\n","type":"(a -> b -> c -> d) -> List.List a -> List.List b -> List.List c -> List.List d"},{"name":"lift4","comment":" Maps a function over four lists, exploring all possible combinations.\n","type":"(a -> b -> c -> d -> e) -> List.List a -> List.List b -> List.List c -> List.List d -> List.List e"},{"name":"mapAccuml","comment":" The mapAccuml function behaves like a combination of map and foldl; it applies a\nfunction to each element of a list, passing an accumulating parameter from left to right,\nand returning a final value of this accumulator together with the new list.\n\n    mapAccuml f a0 [ x1, x2, x3 ] == ( a3, [ y1, y2, y3 ] )\n\n    --        x1    x2    x3\n    --        |     |     |\n    --  a0 -- f --- f --- f -> a3\n    --        |     |     |\n    --        y1    y2    y3\n\nAdd a running total to a list of numbers:\n\n    mapAccuml (\\a x -> ( a + x, ( x, a + x ) )) 0 [ 2, 4, 8 ]\n        --> ( 14, [ ( 2, 2 ), ( 4, 6 ), ( 8, 14 ) ] )\n\nMap number by multiplying with accumulated sum:\n\n    mapAccuml (\\a x -> ( a + x, a * x )) 5 [ 2, 4, 8 ]\n        --> ( 19, [ 10, 28, 88 ] )\n\n","type":"(a -> b -> ( a, c )) -> a -> List.List b -> ( a, List.List c )"},{"name":"mapAccumr","comment":" The mapAccumr function behaves like a combination of map and foldr; it applies a\nfunction to each element of a list, passing an accumulating parameter from right to left,\nand returning a final value of this accumulator together with the new list.\n\n    mapAccumr f a0 [ x1, x2, x3 ] == ( a3, [ y1, y2, y3 ] )\n\n    --        x1    x2    x3\n    --        |     |     |\n    --  a3 <- f --- f --- f -- a0\n    --        |     |     |\n    --        y1    y2    y3\n\nAdd a count of remaining elements:\n\n    mapAccumr (\\a x -> ( a + 1, ( x, a ) )) 0 [ 2, 4, 8 ]\n        --> ( 3, [ ( 2, 2 ), ( 4, 1 ), ( 8, 0 ) ] )\n\nMap number by multiplying with right-to-left accumulated sum:\n\n    mapAccumr (\\a x -> ( a + x, a * x )) 5 [ 2, 4, 8 ]\n        --> ( 19, [ 34, 52, 40 ] )\n\n","type":"(a -> b -> ( a, c )) -> a -> List.List b -> ( a, List.List c )"},{"name":"maximumBy","comment":" Find the first maximum element in a list using a comparable transformation\n","type":"(a -> comparable) -> List.List a -> Maybe.Maybe a"},{"name":"maximumWith","comment":" Find the first maximum element in a list using a comparison function\n\n    maximumWith compare []\n    --> Nothing\n\n    maximumWith\n      (\\x y -> compare x.val y.val)\n      [{id=1, val=1}, {id=2, val=2}, {id=3,val=2}]\n    --> Just { id = 2, val = 2 }\n\n","type":"(a -> a -> Basics.Order) -> List.List a -> Maybe.Maybe a"},{"name":"minimumBy","comment":" Find the first minimum element in a list using a comparable transformation\n","type":"(a -> comparable) -> List.List a -> Maybe.Maybe a"},{"name":"minimumWith","comment":" Find the first minimum element in a list using a comparison function\n\n    minimumWith compare []\n    --> Nothing\n    minimumWith\n      (\\x y -> compare x.val y.val)\n      [{id=1, val=2}, {id=2, val=1}, {id=3,val=1}]\n    --> Just { id = 2, val = 1 }\n\n","type":"(a -> a -> Basics.Order) -> List.List a -> Maybe.Maybe a"},{"name":"notMember","comment":" Negation of `member`.\n\n    notMember 1 [ 1, 2, 3 ]\n    --> False\n\n    notMember 4 [ 1, 2, 3 ]\n    --> True\n\n","type":"a -> List.List a -> Basics.Bool"},{"name":"permutations","comment":" Return the list of of all permutations of a list. The result is in lexicographic order.\n\n    permutations [ 1, 2, 3 ]\n    --> [ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ], [ 3, 2, 1 ] ]\n\n","type":"List.List a -> List.List (List.List a)"},{"name":"remove","comment":" Remove the first occurrence of a value from a list.\n","type":"a -> List.List a -> List.List a"},{"name":"removeAt","comment":" Remove the element at an index from a list. Return the original list if the index is out of range.\n\n    removeAt 0 [ 1, 2, 3 ]\n    --> [ 2, 3 ]\n\nSee also `removeIfIndex`.\n\n","type":"Basics.Int -> List.List a -> List.List a"},{"name":"removeIfIndex","comment":" Remove an element at an index that satisfies a predicate.\n\n    removeIfIndex ((==) 2) [ 1, 2, 3 ]\n    --> [ 1, 2 ]\n\nSee also `removeAt`.\n\n","type":"(Basics.Int -> Basics.Bool) -> List.List a -> List.List a"},{"name":"removeWhen","comment":" Take a predicate and a list, and return a list that contains elements which fails to satisfy the predicate.\nThis is equivalent to `List.filter (not << predicate) list`.\n\n    isEven : Int -> Bool\n    isEven i =\n        modBy 2 i == 0\n\n    removeWhen isEven [ 1, 2, 3, 4 ]\n    --> [ 1, 3 ]\n\n","type":"(a -> Basics.Bool) -> List.List a -> List.List a"},{"name":"reverseMap","comment":" `reverseMap f xs` gives the same result as `List.reverse (List.map f xs)`,\nbut is tail-recursive and slightly more efficient.\n\n    reverseMap sqrt [ 1, 4, 9 ]\n    --> [ 3, 2, 1 ]\n\n","type":"(a -> b) -> List.List a -> List.List b"},{"name":"reverseRange","comment":" Create a list of numbers, every element decreasing by one.\nYou give the highest and lowest number that should be in the list.\nMore efficient than calling `List.reverse (List.range lo hi)`\n\n    range 6 3 == [ 6, 5, 4, 3 ]\n\n    range 3 3 == [ 3 ]\n\n    range 3 6 == []\n\n","type":"Basics.Int -> Basics.Int -> List.List Basics.Int"},{"name":"scanl","comment":" Reduce a list from the left, building up all of the intermediate results into a list.\n\n    scanl (+) 0 [ 1, 2, 3, 4 ]\n    --> [ 0, 1, 3, 6, 10 ]\n\n","type":"(a -> b -> b) -> b -> List.List a -> List.List b"},{"name":"scanl1","comment":" `scanl1` is a variant of `scanl` that has no starting value argument.\n\nCompare:\n\n    scanl (+) 0 [ 1, 2, 3 ]\n    --> [ 0, 1, 3, 6 ]\n\n    scanl1 (+) [ 1, 2, 3 ]\n    --> [ 1, 3, 6 ]\n\n    scanl (-) 0 [ 1, 2, 3 ]\n    --> [ 0, 1, 1, 2 ]\n\n    scanl1 (-) [ 1, 2, 3 ]\n    --> [ 1, 1, 2 ]\n\n","type":"(a -> a -> a) -> List.List a -> List.List a"},{"name":"scanr","comment":" `scanr` is a right-to-left dual of `scanl`. Note that:\n\n    head (scanr f z xs) == foldr f z xs\n\nExamples:\n\n    scanr (+) 0 [ 1, 2, 3 ]\n    --> [ 6, 5, 3, 0 ]\n\n    scanr (-) 0 [ 1, 2, 3 ]\n    --> [ 2, -1, 3, 0 ]\n\n","type":"(a -> b -> b) -> b -> List.List a -> List.List b"},{"name":"scanr1","comment":" `scanr1` is a variant of `scanr` that has no starting value argument.\n\n    scanr1 (+) [ 1, 2, 3 ]\n    --> [ 6, 5, 3 ]\n\n    scanr1 (-) [ 1, 2, 3 ]\n    --> [ 2, -1, 3 ]\n\n","type":"(a -> a -> a) -> List.List a -> List.List a"},{"name":"select","comment":" Return all combinations in the form of (element, rest of the list). Read [Haskell Libraries proposal](https://mail.haskell.org/pipermail/libraries/2008-February/009270.html) for further ideas on how to use this function.\n\n    select [ 1, 2, 3, 4 ]\n    --> [ ( 1, [ 2, 3, 4 ] ), ( 2, [ 1, 3, 4 ] ), ( 3, [ 1, 2, 4 ] ), ( 4, [ 1, 2, 3 ] ) ]\n\n","type":"List.List a -> List.List ( a, List.List a )"},{"name":"selectSplit","comment":" Return all combinations in the form of (elements before, element, elements after).\n\n    selectSplit [ 1, 2, 3 ]\n    --> [ ( [], 1, [ 2, 3 ] ), ( [ 1 ], 2, [ 3 ] ), ( [ 1, 2 ], 3, [] ) ]\n\n","type":"List.List a -> List.List ( List.List a, a, List.List a )"},{"name":"setAt","comment":" Set a value in a list by index. Return the original list if the index is out of range.\n\n    setAt 0 42 [ 1, 2, 3 ]\n    --> [ 42, 2, 3 ]\n\n","type":"Basics.Int -> a -> List.List a -> List.List a"},{"name":"setIf","comment":" Replace all values that satisfy a predicate with a replacement value.\n","type":"(a -> Basics.Bool) -> a -> List.List a -> List.List a"},{"name":"span","comment":" Take a predicate and a list, return a tuple. The first part of the tuple is the longest prefix of that list, for each element of which the predicate holds. The second part of the tuple is the remainder of the list. `span p xs` is equivalent to `(takeWhile p xs, dropWhile p xs)`.\n\n    span ((>) 3) [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n    --> ( [ 1, 2 ], [ 3, 4, 1, 2, 3, 4 ] )\n\n    span ((>) 5) [ 1, 2, 3 ]\n    --> ( [ 1, 2, 3 ], [] )\n\n    span ((>) 0) [ 1, 2, 3 ]\n    --> ( [], [ 1, 2, 3 ] )\n\n","type":"(a -> Basics.Bool) -> List.List a -> ( List.List a, List.List a )"},{"name":"splitAt","comment":" Take a number and a list, return a tuple of lists, where first part is prefix of the list of length equal the number, and second part is the remainder of the list. `splitAt n xs` is equivalent to `(take n xs, drop n xs)`.\n\n    splitAt 3 [ 1, 2, 3, 4, 5 ]\n    --> ( [ 1, 2, 3 ], [ 4, 5 ] )\n\n    splitAt 1 [ 1, 2, 3 ]\n    --> ( [ 1 ], [ 2, 3 ] )\n\n    splitAt 3 [ 1, 2, 3 ]\n    --> ( [ 1, 2, 3 ], [] )\n\n    splitAt 4 [ 1, 2, 3 ]\n    --> ( [ 1, 2, 3 ], [] )\n\n    splitAt 0 [ 1, 2, 3 ]\n    --> ( [], [ 1, 2, 3 ] )\n\n    splitAt -1 [ 1, 2, 3 ]\n    --> ( [], [ 1, 2, 3 ] )\n\n","type":"Basics.Int -> List.List a -> ( List.List a, List.List a )"},{"name":"splitWhen","comment":" Attempts to split the list at the first element where the given predicate is true. If the predicate is not true for any elements in the list, return nothing. Otherwise, return the split list.\n\n    splitWhen (\\n -> n == 3) [ 1, 2, 3, 4, 5 ]\n    --> Just ( [ 1, 2 ], [ 3, 4, 5 ] )\n\n    splitWhen (\\n -> n == 6) [ 1, 2, 3, 4, 5 ]\n    --> Nothing\n\n","type":"(a -> Basics.Bool) -> List.List a -> Maybe.Maybe ( List.List a, List.List a )"},{"name":"stableSortWith","comment":" Similar to List.sortWith, this sorts values with a custom comparison function.\nUnlike List.sortWith, this sort is guaranteed to be a stable sort.\nNote that List.sortWith is faster and is preferred if sort stability is not required.\n","type":"(a -> a -> Basics.Order) -> List.List a -> List.List a"},{"name":"stoppableFoldl","comment":" A `foldl` that can stop early instead of traversing the whole list.\n\n    stoppableFoldl\n        (\\n acc ->\n            if acc >= 50 then\n                Stop acc\n            else\n                Continue (n + acc)\n        )\n        0\n        (List.range 1 10000)\n    --> 55\n\n","type":"(a -> b -> List.Extra.Step b) -> b -> List.List a -> b"},{"name":"stripPrefix","comment":" Drop the given prefix from the list. If the list doesn't start with that prefix, return `Nothing`.\n\n    stripPrefix [ 1, 2 ] [ 1, 2, 3, 4 ]\n    --> Just [ 3, 4 ]\n\n    stripPrefix [ 1, 2, 3 ] [ 1, 2, 3, 4, 5 ]\n    --> Just [ 4, 5 ]\n\n    stripPrefix [ 1, 2, 3 ] [ 1, 2, 3 ]\n    --> Just []\n\n    stripPrefix [ 1, 2, 3 ] [ 1, 2 ]\n    --> Nothing\n\n    stripPrefix [ 3, 2, 1 ] [ 1, 2, 3, 4, 5 ]\n    --> Nothing\n\n","type":"List.List a -> List.List a -> Maybe.Maybe (List.List a)"},{"name":"subsequences","comment":" Return the list of all subsequences of a list.\n\n    subsequences [ 1, 2, 3 ]\n    --> [ [], [ 1 ], [ 2 ], [ 1, 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2, 3 ] ]\n\n","type":"List.List a -> List.List (List.List a)"},{"name":"subsequencesNonEmpty","comment":" Return the list of all subsequences of the argument, except for the empty list.\n\n    subsequencesNonEmpty [ 1, 2, 3 ]\n        == [ [ 1 ], [ 2 ], [ 1, 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2, 3 ] ]\n\n","type":"List.List a -> List.List ( a, List.List a )"},{"name":"swapAt","comment":" Swap two values in a list by index. Return the original list if the index is out of range.\nIf the same index is supplied twice the operation has no effect.\n\n    swapAt 1 2 [ 1, 2, 3 ]\n    --> [ 1, 3, 2 ]\n\n","type":"Basics.Int -> Basics.Int -> List.List a -> List.List a"},{"name":"tails","comment":" Return all final segments of a list, from longest to shortest, the list itself first, empty list last.\n\n    tails [ 1, 2, 3 ]\n    --> [ [ 1, 2, 3 ], [ 2, 3 ], [ 3 ], [] ]\n\n","type":"List.List a -> List.List (List.List a)"},{"name":"takeWhile","comment":" Take elements in order as long as the predicate evaluates to `True`\n","type":"(a -> Basics.Bool) -> List.List a -> List.List a"},{"name":"takeWhileRight","comment":" Take elements from the right, while predicate still holds.\n\n    takeWhileRight ((<) 5) (List.range 1 10)\n    --> [ 6, 7, 8, 9, 10 ]\n\n","type":"(a -> Basics.Bool) -> List.List a -> List.List a"},{"name":"transpose","comment":" Transpose rows and columns of the list of lists.\n\n    transpose [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]\n    --> [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\n\n    transpose [ [ 10, 11 ], [ 20, 40 ], [ 30, 31, 32, 400 ] ]\n    --> [ [ 10, 20, 30 ], [ 11, 40, 31 ] ]\n\n","type":"List.List (List.List a) -> List.List (List.List a)"},{"name":"uncons","comment":" Decompose a list into its head and tail. If the list is empty, return `Nothing`. Otherwise, return `Just (x, xs)`, where `x` is head and `xs` is tail.\n\n    uncons [1,2,3]\n    --> Just (1, [2,3])\n\n    uncons []\n    --> Nothing\n\n","type":"List.List a -> Maybe.Maybe ( a, List.List a )"},{"name":"unconsLast","comment":" Decompose a list into its body and last element. If the list is empty, return `Nothing`. Otherwise, return `Just (x, xs)`, where `x` is the last element and `xs` is the body.\n\n    unconsLast [1,2,3]\n    --> Just (3, [1,2])\n\n    unconsLast []\n    --> Nothing\n\n","type":"List.List a -> Maybe.Maybe ( a, List.List a )"},{"name":"unfoldr","comment":" The `unfoldr` function is \"dual\" to `foldr`. `foldr` reduces a list to a summary value, `unfoldr` builds a list from a seed. The function takes a function and a starting element. It applies the function to the element. If the result is `Just (a, b)`, `a` is accumulated and the function is applied to `b`. If the result is `Nothing`, the list accumulated so far is returned.\n\n    subtractOneUntilZero : Int -> Maybe (Int, Int)\n    subtractOneUntilZero i =\n        if i /= 0 then\n            Just (i, i - 1)\n        else\n            Nothing\n\n    unfoldr subtractOneUntilZero 5\n    --> [ 5, 4, 3, 2, 1 ]\n\n","type":"(b -> Maybe.Maybe ( a, b )) -> b -> List.List a"},{"name":"unique","comment":" Remove duplicate values, keeping the first instance of each element which appears more than once.\n\n    unique [ 0, 1, 1, 0, 1 ]\n    --> [ 0, 1 ]\n\n","type":"List.List a -> List.List a"},{"name":"uniqueBy","comment":" Drop duplicates where what is considered to be a duplicate is the result of first applying the supplied function to the elements of the list.\n","type":"(a -> b) -> List.List a -> List.List a"},{"name":"uniquePairs","comment":" Return all ways to pair the elements of the list.\n(Essentially, enumerate the possible \"handshakes.\")\n\nThe order of the pair elements doesn't matter, so if `(1,2)` is a returned pair,\nwe don't return `(2,1)`.\n\nIn more mathematical terms these are 2-combinations without repetition.\n\n    uniquePairs [ 1, 2, 3, 4 ]\n    --> [ ( 1, 2 ), ( 1, 3 ), ( 1, 4 ), ( 2, 3 ), ( 2, 4 ), ( 3, 4 ) ]\n\nIn this example, everybody shakes hands with three other people.\n\n","type":"List.List a -> List.List ( a, a )"},{"name":"updateAt","comment":" Replace a value at a specific index by calling an update function. Return the original list if the index is out of range.\n\n    updateAt 0 ((+) 1) [ 1, 2, 3 ]\n    --> [ 2, 2, 3 ]\n\nSee also `updateIfIndex`.\n\n","type":"Basics.Int -> (a -> a) -> List.List a -> List.List a"},{"name":"updateIf","comment":" Replace all values that satisfy a predicate by calling an update function.\n","type":"(a -> Basics.Bool) -> (a -> a) -> List.List a -> List.List a"},{"name":"updateIfIndex","comment":" Replace a value at an index that satisfies a predicate, by calling an update function.\n\n    updateIfIndex ((==) 2) ((+) 1) [ 1, 2, 3 ]\n    --> [ 1, 2, 4 ]\n\nSee also `updateAt`.\n\n","type":"(Basics.Int -> Basics.Bool) -> (a -> a) -> List.List a -> List.List a"},{"name":"zip","comment":" Take two lists and returns a list of corresponding pairs\n","type":"List.List a -> List.List b -> List.List ( a, b )"},{"name":"zip3","comment":" Take three lists and returns a list of triples\n","type":"List.List a -> List.List b -> List.List c -> List.List ( a, b, c )"}],"binops":[]},{"name":"Maybe.Extra","comment":" Convenience functions for [`Maybe`](https://package.elm-lang.org/packages/elm/core/latest/Maybe).\n\n\n# Basics\n\nWork with 1 `Maybe`\n\n@docs isJust, isNothing, join, filter\n\n\n# Get a value out of a `Maybe`\n\n@docs withDefaultLazy, unwrap, unpack\n\n\n# OR based logic\n\nTake the first value that's present\n\n@docs or, orElse, orList, orLazy, orElseLazy, orListLazy, oneOf\n\n\n# Lists of `Maybe`s\n\n@docs values\n\n\n# Combining\n\n@docs combine, combineMap, combineArray, combineMapArray, combineFirst, combineSecond, combineBoth, combineMapFirst, combineMapSecond, combineMapBoth\n\n\n# Transforming to collections\n\n@docs toList, toArray\n@docs cons\n\n\n# andThenN\n\nThese functions are just like [`andThen`](https://package.elm-lang.org/packages/elm/core/latest/Maybe#andThen), except they take multiple arguments.\n\nAll arguments must be `Just` and the function must return a `Just` for the maybe to be `Just`.\n\nIf you need a version of `andThenN` that takes more than 4 arguments, you can chain together [`andMap`](#andMap) calls in a pipeline.\n\n@docs andThen2, andThen3, andThen4\n\n\n# Applicative Functions\n\n@docs andMap, next, prev\n\n","unions":[],"aliases":[],"values":[{"name":"andMap","comment":" If both a function and a value are present, apply the function to the value.\nIf either argument is `Nothing`, return `Nothing`.\n\n    Just ((+) 2)\n        |> andMap (Just 3)\n    --> Just 5\n\n    Nothing\n        |> andMap (Just 3)\n    --> Nothing\n\n    Just ((+) 2)\n        |> andMap Nothing\n    --> Nothing\n\nThis can be used to do [`Maybe.mapN`](https://package.elm-lang.org/packages/elm/core/latest/Maybe#map2) or [`andThenN`](#andthenn) for any number of arguments.\n\n    -- map4\n    Just (\\a b c d -> a + b + c + d )\n        |> andMap (Just 1)\n        |> andMap (Just 2)\n        |> andMap (Just 4)\n        |> andMap (Just 8)\n    --> Just 15\n\n    -- andThen4\n    Just (\\a b c d -> Just (a + b + c + d ))\n        |> andMap (Just 1)\n        |> andMap (Just 2)\n        |> andMap (Just 4)\n        |> andMap (Just 8)\n        |> join\n    --> Just 15\n\nAdvanced functional programmers will recognize this as the implementation of `<*>` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe (a -> b) -> Maybe.Maybe b"},{"name":"andThen2","comment":"\n\n    import Array exposing (Array)\n\n    array : Array Int\n    array = Array.fromList [1,2,3]\n\n    andThen2 Array.get (Just 1) (Just array)\n    --> Just 2\n\n    andThen2 Array.get Nothing (Just array)\n    --> Nothing\n\n    andThen2 Array.get (Just 1) Nothing\n    --> Nothing\n\n    andThen2 Array.get (Just 4) (Just array)\n    --> Nothing\n\n","type":"(a -> b -> Maybe.Maybe value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe value"},{"name":"andThen3","comment":" `andThen` for 3 maybes.\n","type":"(a -> b -> c -> Maybe.Maybe value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe c -> Maybe.Maybe value"},{"name":"andThen4","comment":" `andThen` for 4 maybes.\n","type":"(a -> b -> c -> d -> Maybe.Maybe value) -> Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe c -> Maybe.Maybe d -> Maybe.Maybe value"},{"name":"combine","comment":" If every `Maybe` in the list is present, return all of the values unwrapped.\nIf there are any `Nothing`s, the whole function fails and returns `Nothing`.\n\n    combine []\n    --> Just []\n\n    combine [ Just 1, Just 2, Just 3 ]\n    --> Just [ 1, 2, 3 ]\n\n    combine [ Just 1, Nothing, Just 3 ]\n    --> Nothing\n\n","type":"List.List (Maybe.Maybe a) -> Maybe.Maybe (List.List a)"},{"name":"combineArray","comment":" Like [`combine`](#combine),\nbut works on [`Array`](https://package.elm-lang.org/packages/elm/core/latest/Array) instead of `List`.\n","type":"Array.Array (Maybe.Maybe a) -> Maybe.Maybe (Array.Array a)"},{"name":"combineBoth","comment":" Combine all maybes in a tuple\ninto a single maybe holding the tuple's values.\n","type":"( Maybe.Maybe a, Maybe.Maybe b ) -> Maybe.Maybe ( a, b )"},{"name":"combineFirst","comment":" Pull a maybe out of the _first_ element of a tuple\nand combine it into a maybe holding the tuple's values.\n","type":"( Maybe.Maybe a, c ) -> Maybe.Maybe ( a, c )"},{"name":"combineMap","comment":" Like [`combine`](#combine), but map a function over each element of the list first.\n\nIf every function call succeeds (returns `Just`), `combineMap` will return a list.\nIf any function call fails (returns `Nothing`), `combineMap` will return `Nothing`.\n\n`combine` is equivalent to `combineMap identity`.\n\n    combineMap (\\x -> Just (x * 10)) [ 1, 2, 3, 4, 5 ]\n    --> Just [ 10, 20, 30, 40, 50 ]\n\n    combineMap List.head [ [1], [2, 3], [] ]\n    --> Nothing\n\n","type":"(a -> Maybe.Maybe b) -> List.List a -> Maybe.Maybe (List.List b)"},{"name":"combineMapArray","comment":" Like [`combineMap`](#combineMap),\nbut works on [`Array`](https://package.elm-lang.org/packages/elm/core/latest/Array) instead of `List`.\n","type":"(a -> Maybe.Maybe b) -> Array.Array a -> Maybe.Maybe (Array.Array b)"},{"name":"combineMapBoth","comment":" Map a function producing maybes on the _both_ elements of a tuple\nand then pull them out using `combineBoth`.\n\n    combineMapBoth f g ( x, y )\n        == combineBoth (Tuple.mapBoth f g ( x, y ))\n        == Maybe.map2 Tuple.pair (f x) (g y)\n\n","type":"(a -> Maybe.Maybe c) -> (b -> Maybe.Maybe d) -> ( a, b ) -> Maybe.Maybe ( c, d )"},{"name":"combineMapFirst","comment":" Map a function producing maybes on the _first_ element of a tuple\nand then pull it out using `combineFirst`.\n\n    combineMapFirst f ( x, y )\n        == combineFirst (Tuple.mapFirst f ( x, y ))\n        == Maybe.map (\\newX -> ( newX, y )) (f x)\n\n","type":"(a -> Maybe.Maybe b) -> ( a, c ) -> Maybe.Maybe ( b, c )"},{"name":"combineMapSecond","comment":" Map a function producing maybes on the _second_ element of a tuple\nand then pull it out using `combineSecond`.\n\n    combineMapSecond f ( x, y )\n        == combineSecond (Tuple.mapSecond f ( x, y ))\n        == Maybe.map (Tuple.pair x) (f y)\n\n","type":"(a -> Maybe.Maybe b) -> ( c, a ) -> Maybe.Maybe ( c, b )"},{"name":"combineSecond","comment":" Pull a result out of the _second_ element of a tuple\nand combine it into a result holding the tuple's values.\nAlso known as `sequence` on tuples.\n","type":"( c, Maybe.Maybe a ) -> Maybe.Maybe ( c, a )"},{"name":"cons","comment":" Add an item to a list only if it's a `Just`.\n\n    cons (Just 1) [ 2, 3 ]\n    --> [ 1, 2, 3 ]\n\n    cons Nothing [2, 3 ]\n    --> [ 2, 3 ]\n\n","type":"Maybe.Maybe a -> List.List a -> List.List a"},{"name":"filter","comment":" Keep the `Maybe` only if the predicate function passes\n\n    filter (\\v -> v == 1) (Just 1)\n    --> Just 1\n\n    filter (\\v -> v == 2) (Just 1)\n    --> Nothing\n\n    filter (\\v -> v == 1) Nothing\n    --> Nothing\n\n","type":"(a -> Basics.Bool) -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"isJust","comment":"\n\n    isJust (Just 42)\n    --> True\n\n    isJust (Just [])\n    --> True\n\n    isJust Nothing\n    --> False\n\n","type":"Maybe.Maybe a -> Basics.Bool"},{"name":"isNothing","comment":"\n\n    isNothing (Just 42)\n    --> False\n\n    isNothing (Just [])\n    --> False\n\n    isNothing Nothing\n    --> True\n\n","type":"Maybe.Maybe a -> Basics.Bool"},{"name":"join","comment":" Flattens nested `Maybe`s\n\n    join (Just (Just 1))\n    --> Just 1\n\n    join (Just Nothing)\n    --> Nothing\n\n    join Nothing\n    --> Nothing\n\n","type":"Maybe.Maybe (Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"next","comment":" Take two `Maybe` values. If the first one equals `Nothing`, return `Nothing`. Otherwise return the second value.\n\n    next (Just 1) (Just 2)\n    --> Just 2\n\n    next Nothing (Just 2)\n    --> Nothing\n\n    next (Just 1) Nothing\n    --> Nothing\n\nAdvanced functional programmers will recognize this as the implementation of `*>` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe b"},{"name":"oneOf","comment":" Try a list of functions against a value. Return the value of the first call that succeeds (returns `Just`).\n\n    type UserInput\n        = FloatInput Float\n        | IntInput Int\n        | UnknownInput\n\n    \"5.6\"\n        |> oneOf\n            [ String.toInt >> Maybe.map IntInput\n            , String.toFloat >> Maybe.map FloatInput\n            ]\n        |> Maybe.withDefault UnknownInput\n    --> FloatInput 5.6\n\n","type":"List.List (a -> Maybe.Maybe b) -> a -> Maybe.Maybe b"},{"name":"or","comment":" Returns the first value that is present, like the boolean `||`.\n\nBoth values will be computed. There is no short-circuiting.\nIf your second argument is expensive to calculate and you need short circuiting, use [`orLazy`](#orLazy) instead.\n\n    or (Just 4) (Just 5)\n    --> Just 4\n\n    or (Just 4) Nothing\n    --> Just 4\n\n    or Nothing (Just 5)\n    --> Just 5\n\n    or Nothing Nothing\n    --> Nothing\n\nAdvanced functional programmers will recognize this as the\nimplementation of `mplus` for `Maybe`s from the `MonadPlus` type\nclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orElse","comment":" Piping-friendly version of [`or`](#or).\n\n    Just 5\n        |> orElse (Just 4)\n    --> Just 5\n\n    orElse (Just 4) (Just 5)\n    --> Just 5\n\n    List.head []\n        |> orElse (List.head [ 4 ])\n    --> Just 4\n\n","type":"Maybe.Maybe a -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orElseLazy","comment":" Lazy version of [`orElse`](#orElse).\nPiping-friendly version of [`orLazy`](#orLazy).\n\nThe first argument will only be evaluated if the second argument is `Nothing`.\n\n    Just 4\n        |> orElseLazy (\\() -> Debug.todo \"Expensive calculation\")\n    --> Just 4\n\n","type":"(() -> Maybe.Maybe a) -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orLazy","comment":" Lazy version of [`or`](#or).\n\nThe second argument will only be evaluated if the first argument is `Nothing`.\n\n    orLazy (Just 4) (\\() -> Debug.todo \"Expensive calculation\")\n    --> Just 4\n\n","type":"Maybe.Maybe a -> (() -> Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"orList","comment":" Returns the first value that is present.\n\nAll values will be computed.\nIf your arguments are expensive to calculate, use [`orListLazy`](#orListLazy) instead.\n\n    orList\n        [ Nothing\n        , Just 1\n        , Just 2\n        ]\n    --> Just 1\n\n    orList\n        [ List.head []\n        , String.toInt \"\"\n        ]\n    --> Nothing\n\n    orList []\n    --> Nothing\n\n","type":"List.List (Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"orListLazy","comment":" Lazy version of [`orList`](#orList)\n\nStops calculating new values after the first match\n\n    orListLazy\n        [ \\() -> Nothing\n        , \\() -> Just 1\n        , \\() -> Debug.todo \"Expensive calculation\"\n        ]\n    --> Just 1\n\n","type":"List.List (() -> Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"prev","comment":" Take two `Maybe` values. If the second one equals `Nothing`, return `Nothing`. Otherwise return the first value.\n\n    prev (Just 1) (Just 2)\n    --> Just 1\n\n    prev Nothing (Just 2)\n    --> Nothing\n\n    prev (Just 1) Nothing\n    --> Nothing\n\nAdvanced functional programmers will recognize this as the implementation of `<*` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe a"},{"name":"toArray","comment":" Like `toList`, but returns a singleton or empty [`Array`](https://package.elm-lang.org/packages/elm/core/latest/Array).\n\n    import Array\n\n    toArray Nothing\n    --> Array.fromList []\n\n    toArray (Just 1)\n    --> Array.fromList [ 1 ]\n\n","type":"Maybe.Maybe a -> Array.Array a"},{"name":"toList","comment":" A `Maybe` is a lot like a list that can only be length 0 or 1.\n\nReturns a singleton list if the value is present, and an empty list it's missing.\n\n    toList Nothing\n    --> []\n\n    toList (Just 1)\n    --> [ 1 ]\n\n","type":"Maybe.Maybe a -> List.List a"},{"name":"unpack","comment":" Like [`unwrap`](#unwrap), but the default value is lazy,\nand will only be computed if the `Maybe` is `Nothing`.\n\n    unpack (\\() -> 0) String.length Nothing\n    --> 0\n\n    unpack (\\() -> 0) String.length (Just \"abc\")\n    --> 3\n\n`unpack (\\() -> default) f maybeX` is equivalent to\n\n    case maybeX of\n        Just x ->\n            f x\n\n        Nothing ->\n            default\n\n","type":"(() -> b) -> (a -> b) -> Maybe.Maybe a -> b"},{"name":"unwrap","comment":" Like using a `case`.\nGive a function that says what to do if the input is `Just`,\nand a value to use if the input is `Nothing`.\n\nThese are all equivalent:\n\n    unwrap default f maybeX\n\n    maybeX\n        |> Maybe.map f\n        |> Maybe.withDefault default\n\n    case maybeX of\n        Just x ->\n            f x\n\n        Nothing ->\n            default\n\nExcept that unlike a `case`, the default value for `unwrap` is always computed.\nIf your default value is expensive to compute, use the lazy [`unpack`](#unpack) instead.\n\nExamples:\n\n    unwrap 0 String.length Nothing\n    --> 0\n\n    unwrap 0 String.length (Just \"abc\")\n    --> 3\n\n","type":"b -> (a -> b) -> Maybe.Maybe a -> b"},{"name":"values","comment":" Take all the values that are present, throwing away any `Nothing`s.\n\nEquivalent to [`List.filterMap identity`](https://package.elm-lang.org/packages/elm/core/latest/List#filterMap).\n\n    values [ Just 1, Nothing, Just 2 ]\n    --> [ 1, 2 ]\n\n","type":"List.List (Maybe.Maybe a) -> List.List a"},{"name":"withDefaultLazy","comment":" Lazy version of [Maybe.withDefault](https://package.elm-lang.org/packages/elm/core/latest/Maybe#withDefault).\n\nIt will only calculate the default if needed.\n\nExamples:\n\n    withDefaultLazy (\\() -> 2 + 2) Nothing\n    --> 4\n\n    withDefaultLazy (\\() -> Debug.todo \"Expensive calculation\") (Just 4)\n    --> 4\n\n","type":"(() -> a) -> Maybe.Maybe a -> a"}],"binops":[]},{"name":"Order.Extra","comment":" Library for building comparison functions.\n\nThis library makes it easy to create comparison functions for arbitary types by composing\nsmaller comparison functions. For instance, suppose you are defining a data type to represent\na standard deck of cards. You might define it as:\n\n    type alias Card =\n        { value : Value, suite : Suite }\n\n    type Suite\n        = Clubs\n        | Hearts\n        | Diamonds\n        | Spades\n\n    type Value\n        = Two\n        | Three\n        | Four\n        | Five\n        | Six\n        | Seven\n        | Eight\n        | Nine\n        | Ten\n        | Jack\n        | Queen\n        | King\n        | Ace\n\nWith this representation, you could define an ordering for `Card` values compositionally:\n\n    import Order.Extra\n\n    cardOrdering : Card -> Card -> Order\n    cardOrdering =\n        Ordering.byFieldWith suiteOrdering .suite\n            |> Ordering.breakTiesWith\n                (Ordering.byFieldWith valueOrdering .value)\n\n    suiteOrdering : Suite -> Suite -> Order\n    suiteOrdering =\n        Ordering.explicit [ Clubs, Hearts, Diamonds, Spades ]\n\n    valueOrdering : Value -> Value -> Order\n    valueOrdering =\n        Ordering.explicit\n            [ Two\n            , Three\n            , Four\n            , Five\n            , Six\n            , Seven\n            , Eight\n            , Nine\n            , Ten\n            , Jack\n            , Queen\n            , King\n            , Ace\n            ]\n\nYou can then use this ordering to sort cards, make comparisons, and so on. For instance,\nto sort a deck of cards you can use `cardOrdering` directly:\n\n    sortCards : List Card -> List Card\n    sortCards =\n        List.sortWith cardOrdering\n\n\n# Construction\n\n@docs explicit, byField, byFieldWith, byRank, ifStillTiedThen\n\n\n# Composition\n\n@docs breakTies, breakTiesWith, reverse\n\n\n# Strings\n\n@docs natural\n\n\n# Utility\n\n@docs isOrdered, greaterThanBy, lessThanBy\n\n","unions":[],"aliases":[],"values":[{"name":"breakTies","comment":" Create an ordering function that can be used to sort\nlists by multiple dimensions, by flattening multiple ordering functions into one.\n\nThis is equivalent to `ORDER BY` in SQL. The ordering function will order\nits inputs based on the order that they appear in the `List (a -> a -> Order)` argument.\n\n    type alias Pen =\n        { model : String\n        , tipWidthInMillimeters : Float\n        }\n\n    pens : List Pen\n    pens =\n        [ Pen \"Pilot Hi-Tec-C Gel\" 0.4\n        , Pen \"Morning Glory Pro Mach\" 0.38\n        , Pen \"Pilot Hi-Tec-C Coleto\" 0.5\n        ]\n\n    order : Pen -> Pen -> Order\n    order =\n        breakTies [ byField .tipWidthInMillimeters, byField .model ]\n\n    List.sortWith order pens\n    --> [ Pen \"Morning Glory Pro Mach\" 0.38\n    --> , Pen \"Pilot Hi-Tec-C Gel\" 0.4\n    --> , Pen \"Pilot Hi-Tec-C Coleto\" 0.5\n    --> ]\n\nIf our `Pen` type alias above was represented a row in a database table, our `order` function as defined above would be equivalent\nto this SQL clause:\n\n    ORDER BY tipWidthInMillimeters, model\n\n","type":"List.List (a -> a -> Basics.Order) -> a -> a -> Basics.Order"},{"name":"breakTiesWith","comment":" Produces an ordering that refines the second input ordering by using the first\na -> a -> Orders a tie breaker. (Note that the second argument is the primary sort, and\nthe first argument is a tie breaker. This argument ordering is intended to support\nfunction chaining with `|>`.)\n\n    type alias Point =\n        { x : Int, y : Int }\n\n    pointOrdering : Point -> Point -> Order\n    pointOrdering =\n        Order.Extra.byField .x\n            |> Order.Extra.breakTiesWith (Order.Extra.byField .y)\n\n","type":"(a -> a -> Basics.Order) -> (a -> a -> Basics.Order) -> a -> a -> Basics.Order"},{"name":"byField","comment":" Produces an ordering that orders its elements using the natural ordering of the\nfield selected by the given function.\n\n    type alias Point = { x : Int, y : Int }\n\n    List.sortWith (Order.Extra.byField .x) [Point 3 5, Point 1 6]\n        --> [Point 1 6, Point 3 5]\n    List.sortWith (Order.Extra.byField .y) [Point 3 5, Point 1 6]\n        --> [Point 3 5, Point 1 6]\n\n","type":"(a -> comparable) -> a -> a -> Basics.Order"},{"name":"byFieldWith","comment":" Produces an ordering that orders its elements using the given ordering on the\nfield selected by the given function.\n\n    cards : List Card\n    cards =\n        [ Card King Hearts, Card King Hearts ]\n\n    List.sortWith\n        (Order.Extra.byFieldWith valueOrdering .value)\n        cards\n        == [ Card Two Spades,  Card King Hearts]\n\n    List.sortWith\n        (Order.Extra.byFieldWith suiteOrdering .suite)\n        cards\n        == [ Card King Hearts, Card Two Spades ]\n\n","type":"(b -> b -> Basics.Order) -> (a -> b) -> a -> a -> Basics.Order"},{"name":"byRank","comment":" Produces an ordering defined by an explicit ranking function combined with a\nsecondary ordering function to compare elements within the same rank. The rule is\nthat all items are sorted first by rank, and then using the given within-rank\nordering for items of the same rank.\n\nThis function is intended for use with types that have multiple cases where\nconstructors for some or all of the cases take arguments. (Otherwise use `Ordering.explicit`\ninstead which has a simpler interface.) For instance, to make an ordering for\na type such as:\n\n    type JokerCard\n        = NormalCard Value Suite\n        | Joker\n\nyou could use `byRank` to sort all the normal cards before the jokers like so:\n\n    jokerCardOrdering : JokerCard -> JokerCard -> Order\n    jokerCardOrdering =\n        Order.Extra.byRank\n            (\\card ->\n                case card of\n                    NormalCard _ _ ->\n                        1\n\n                    Joker ->\n                        2\n            )\n            (\\x y ->\n                case ( x, y ) of\n                    ( NormalCard v1 s1, NormalCard v2 s2 ) ->\n                        suiteOrdering s1 s2\n                            |> Order.Extra.ifStillTiedThen\n                                (valueOrdering v1 v2)\n\n                    _ ->\n                        EQ\n            )\n\nMore generally, the expected pattern is that for each case in your type, you assign\nthat case to a unique rank with the ranking function. Then for your within-rank\nordering, you have a case statement that enumerates all the \"tie\" states and\nspecifies how to break ties, and then uses a catch-all case that returns\n`Ordering.noConflicts` to specify that all remaining cases cannot give rise to\nthe need to do any subcomparisons. (This can be either because the values being\ncompared have no internal structure and so are always equal, or because they are\nconstructors with different ranks and so will never be compared by this function.)\n\n","type":"(a -> Basics.Int) -> (a -> a -> Basics.Order) -> a -> a -> Basics.Order"},{"name":"explicit","comment":" Creates an ordering that orders items in the order given in the input list.\nItems that are not part of the input list are all considered to be equal to each\nother and less than anything in the list.\n\n    type Day\n        = Mon\n        | Tue\n        | Wed\n        | Thu\n        | Fri\n        | Sat\n        | Sun\n\n    dayOrdering : Day -> Day -> Order\n    dayOrdering =\n        Order.Extra.explicit\n            [ Mon, Tue, Wed, Thu, Fri, Sat, Sun ]\n\n","type":"List.List a -> a -> a -> Basics.Order"},{"name":"greaterThanBy","comment":" Determines if one value is greater than another according to the given ordering.\n\n    greaterThanBy\n        xThenYOrdering\n        { x = 7, y = 8 }\n        { x = 10, y = 2 }\n        == False\n\n    greaterThanBy\n        yThenXOrdering\n        { x = 7, y = 8 }\n        { x = 10, y = 2 }\n        == True\n\n","type":"(a -> a -> Basics.Order) -> a -> a -> Basics.Bool"},{"name":"ifStillTiedThen","comment":" Returns the main order unless it is `EQ`, in which case returns the tiebreaker.\n\nThis function does for `Order`s what `breakTiesWith` does for `Ordering`s. It is\nuseful in cases where you want to perform a cascading comparison of multiple pairs\nof values that are not wrapped in a container value, as happens when examining the\nindividual fields of a constructor.\n\n","type":"Basics.Order -> Basics.Order -> Basics.Order"},{"name":"isOrdered","comment":" Determines if the given list is ordered according to the given ordering.\n\n    Order.Extra.isOrdered compare [ 1, 2, 3 ]\n        --> True\n\n    Order.Extra.isOrdered compare [ 2, 1, 3 ]\n        --> False\n\n    Order.Extra.isOrdered compare []\n        --> True\n\n    Order.Extra.isOrdered\n        (Order.Extra.reverse compare)\n        [ 1, 2, 3 ]\n        --> False\n\n","type":"(a -> a -> Basics.Order) -> List.List a -> Basics.Bool"},{"name":"lessThanBy","comment":" Determines if one value is less than another according to the given ordering.\n\n    lessThanBy\n        xThenYOrdering\n        { x = 7, y = 8 }\n        { x = 10, y = 2 }\n        == True\n\n    lessThanBy\n        yThenXOrdering\n        { x = 7, y = 8 }\n        { x = 10, y = 2 }\n        == False\n\n","type":"(a -> a -> Basics.Order) -> a -> a -> Basics.Bool"},{"name":"natural","comment":" Compare two strings naturally.\n\n    List.sortWith Order.Extra.natural [\"a10\", \"a2\"]\n    --> [\"a2\", \"a10\"]\n\nWithout full I18n support, this is probably the best way to sort\nuser provided strings in a way that is intuitive to humans.\n\n","type":"String.String -> String.String -> Basics.Order"},{"name":"reverse","comment":" Returns an ordering that reverses the input ordering.\n\n    List.sortWith\n        (Order.Extra.reverse compare)\n        [ 1, 2, 3, 4, 5 ]\n        --> [ 5, 4, 3, 2, 1 ]\n\n","type":"(a -> a -> Basics.Order) -> a -> a -> Basics.Order"}],"binops":[]},{"name":"Result.Extra","comment":" Convenience functions for working with `Result`.\n\n\n# Common Helpers\n\n@docs isOk, isErr, extract, unwrap, unpack, error, mapBoth, merge, join, partition, filter\n\n\n# Combining\n\n@docs combine, combineMap, combineArray, combineMapArray, combineFirst, combineSecond, combineBoth, combineMapFirst, combineMapSecond, combineMapBoth\n\n\n# Applying\n\n@docs andMap\n\n\n# Alternatives\n\n@docs or, orLazy, orElseLazy, orElse\n\n\n# Conversions\n\n@docs toTask\n\n","unions":[],"aliases":[],"values":[{"name":"andMap","comment":" Apply the function that is inside `Result` to a value that is inside\n`Result`. Return the result inside `Result`. If one of the `Result`\narguments is `Err e`, return `Err e`. Also known as `apply`.\n\n    Err \"Oh\" |> andMap (Err \"No!\") == Err \"Oh\"\n\n    Err \"Oh\" |> andMap (Ok 2) == Err \"Oh\"\n\n    Ok ((+) 1) |> andMap (Err \"No!\") == Err \"No!\"\n\n    Ok ((+) 1) |> andMap (Ok 2) == Ok 3\n\n","type":"Result.Result e a -> Result.Result e (a -> b) -> Result.Result e b"},{"name":"combine","comment":" Combine a list of results into a single result (holding a list).\nAlso known as `sequence` on lists.\n","type":"List.List (Result.Result x a) -> Result.Result x (List.List a)"},{"name":"combineArray","comment":" Like [`combine`](#combine),\nbut works on [`Array`](https://package.elm-lang.org/packages/elm/core/latest/Array) instead of `List`.\n","type":"Array.Array (Result.Result x a) -> Result.Result x (Array.Array a)"},{"name":"combineBoth","comment":" Combine all results in a tuple\ninto a single result holding the tuple's values.\nAlso know as `bisequence` on tuples.\n","type":"( Result.Result x a, Result.Result x b ) -> Result.Result x ( a, b )"},{"name":"combineFirst","comment":" Pull a result out of the _first_ element of a tuple\nand combine it into a result holding the tuple's values.\n","type":"( Result.Result x a, c ) -> Result.Result x ( a, c )"},{"name":"combineMap","comment":" Map a function producing results on a list\nand combine those into a single result (holding a list).\nAlso known as `traverse` on lists.\n\n    combineMap f xs == combine (List.map f xs)\n\n","type":"(a -> Result.Result x b) -> List.List a -> Result.Result x (List.List b)"},{"name":"combineMapArray","comment":" Like [`combineMap`](#combineMap),\nbut works on [`Array`](https://package.elm-lang.org/packages/elm/core/latest/Array) instead of `List`.\n","type":"(a -> Result.Result x b) -> Array.Array a -> Result.Result x (Array.Array b)"},{"name":"combineMapBoth","comment":" Map a function producing results on the _both_ elements of a tuple\nand then pull them out using `combineBoth`.\nAlso know as `bitraverse` on tuples.\n\n    combineMapBoth f g ( x, y )\n        == combineBoth (Tuple.mapBoth f g ( x, y ))\n        == Result.map2 Tuple.pair (f x) (g y)\n\n","type":"(a -> Result.Result x c) -> (b -> Result.Result x d) -> ( a, b ) -> Result.Result x ( c, d )"},{"name":"combineMapFirst","comment":" Map a function producing results on the _first_ element of a tuple\nand then pull it out using `combineFirst`.\nAlso know as `sequence` on tuples.\n\n    combineMapFirst f ( x, y )\n        == combineFirst (Tuple.mapFirst f ( x, y ))\n        == Result.map (\\newX -> ( newX, y )) (f x)\n\n","type":"(a -> Result.Result x b) -> ( a, c ) -> Result.Result x ( b, c )"},{"name":"combineMapSecond","comment":" Map a function producing results on the _second_ element of a tuple\nand then pull it out using `combineSecond`.\nAlso know as `traverse` on tuples.\n\n    combineMapSecond f ( x, y )\n        == combineSecond (Tuple.mapSecond f ( x, y ))\n        == Result.map (Tuple.pair x) (f y)\n\n","type":"(a -> Result.Result x b) -> ( c, a ) -> Result.Result x ( c, b )"},{"name":"combineSecond","comment":" Pull a result out of the _second_ element of a tuple\nand combine it into a result holding the tuple's values.\nAlso known as `sequence` on tuples.\n","type":"( c, Result.Result x a ) -> Result.Result x ( c, a )"},{"name":"error","comment":" Convert to a Maybe containing the error, if there is one.\n\n    parseInt : String -> Result ParseError Int\n\n    maybeParseError : String -> Maybe ParseError\n    maybeParseError string =\n        error (parseInt string)\n\n","type":"Result.Result e a -> Maybe.Maybe e"},{"name":"extract","comment":" Turn a `Result e a` to an `a`, by applying the conversion\nfunction specified to the `e`.\n","type":"(e -> a) -> Result.Result e a -> a"},{"name":"filter","comment":" Take a `Result` and a predicate function and return a `Result` with the\noriginal value when a predicate matches.\n\n    filter \"is not 1\" (\\v -> v == 1) (Ok 1) == Ok 1\n\n    filter \"is not 2\" (\\v -> v == 2) (Ok 1) == Err \"is not 2\"\n\n","type":"e -> (a -> Basics.Bool) -> Result.Result e a -> Result.Result e a"},{"name":"isErr","comment":" Check whether the result is `Err` without unwrapping it.\n","type":"Result.Result e a -> Basics.Bool"},{"name":"isOk","comment":" Check whether the result is `Ok` without unwrapping it.\n","type":"Result.Result e a -> Basics.Bool"},{"name":"join","comment":" Join contained results with the same error into one result.\n\nUsefull if you have a \"result in a result\":\n\n    join <| Ok (Ok 4) == Ok 4\n\n    join <| Ok (Err \"message\") == Err \"message\"\n\n","type":"Result.Result x (Result.Result x a) -> Result.Result x a"},{"name":"mapBoth","comment":" Apply the first argument function to an `Err` and the second\nargument function to an `Ok` of a `Result`.\n","type":"(e -> f) -> (a -> b) -> Result.Result e a -> Result.Result f b"},{"name":"merge","comment":" Eliminate Result when error and success have been mapped to the same\ntype, such as a message type.\n\n    merge (Ok 4) == 4\n\n    merge (Err -1) == -1\n\nMore pragmatically:\n\n    type Msg\n        = UserTypedInt Int\n        | UserInputError String\n\n    msgFromInput : String -> Msg\n    msgFromInput =\n        String.toInt\n            >> Result.mapError UserInputError\n            >> Result.map UserTypedInt\n            >> Result.Extra.merge\n\n","type":"Result.Result a a -> a"},{"name":"or","comment":" Like the Boolean `||` this will return the first value that is\npositive (`Ok`). However, unlike with `||`, both values will be\ncomputed anyway (there is no short-circuiting).\n\n    or (Ok 4) (Ok 5) == Ok 4\n\n    or (Err \"Oh!\") (Ok 5) == Ok 5\n\n    or (Ok 4) (Err \"No!\") == Ok 4\n\n    or (Err \"Oh!\") (Err \"No!\") == Err \"No!\"\n\nAs the last example line shows, the second error is returned if both\nresults are erroneous.\n\n","type":"Result.Result e a -> Result.Result e a -> Result.Result e a"},{"name":"orElse","comment":" Strict version of `orElseLazy` (and at the same time,\npiping-friendly version of `or`).\n\n    orElse (Ok 4) (Ok 5) == Ok 5 -- crucial difference from `or`\n\n    orElse (Err \"Oh!\") (Ok 5) == Ok 5\n\n    orElse (Ok 4) (Err \"No!\") == Ok 4\n\n    orElse (Err \"Oh!\") (Err \"No!\") == Err \"Oh!\" -- also different from `or`\n\nAlso:\n\n    String.toInt \"Hello\"\n        |> orElse (String.toInt \"42\")\n\n","type":"Result.Result e a -> Result.Result e a -> Result.Result e a"},{"name":"orElseLazy","comment":" Piping-friendly version of `orLazy`. The first argument will only\nbe evaluated if the second argument is an `Err`. Example use:\n\n    String.toInt \"Hello\"\n        |> orElseLazy (\\() -> String.toInt \"42\")\n\n","type":"(() -> Result.Result e a) -> Result.Result e a -> Result.Result e a"},{"name":"orLazy","comment":" Non-strict version of `or`. The second argument will only be\nevaluated if the first argument is an `Err`.\n","type":"Result.Result e a -> (() -> Result.Result e a) -> Result.Result e a"},{"name":"partition","comment":" Partition a list of Results into two lists of values (successes\nand failures), much as List.partition takes a predicate and splits\na list based on whether the predicate indicates success or failure.\n\n    partition ( Ok 4, Err \"no\", Err \"hi\" ) == ( [ 4 ], [ \"no\", \"hi\" ] )\n\n    partition ( Err 7.1, Ok 'k', Err 9.0, Ok 'p' ) == ( [ 'k', 'p' ], [ 7.1, 9.0 ] )\n\n","type":"List.List (Result.Result e a) -> ( List.List a, List.List e )"},{"name":"toTask","comment":" Convert a `Result` to a `Task` that will fail or succeed immediately.\n\n    toTask (Ok 4) == Task.succeed 4\n\n    toTask (Err \"msg\") == Task.fail \"msg\"\n\nThis can be helpful when the value of a succeeding Task needs to be decoded, but\na failure to decode should result in a failing `Task`, not a succeeding Task\ncontaining a `Result.Err`:\n\n    andThenDecode : (a -> Result x b) -> Task x a -> Task x b\n    andThenDecode decode =\n        Task.andThen (decode >> Result.Extra.toTask)\n\n","type":"Result.Result x a -> Task.Task x a"},{"name":"unpack","comment":" Convert a `Result e a` to a `b` by applying either the first\nfunction if the `Result` is an `Err` or the second function if the\n`Result` is `Ok`. Both of these functions must return the same type.\n","type":"(e -> b) -> (a -> b) -> Result.Result e a -> b"},{"name":"unwrap","comment":" Convert a `Result e a` to a `b` by applying a function if\nthe `Result` is `Ok` or using the provided default value if it\nis an `Err`.\n","type":"b -> (a -> b) -> Result.Result e a -> b"}],"binops":[]},{"name":"Set.Extra","comment":" Convenience functions for working with Set.\n\n\n# Toggling elements\n\n@docs toggle\n\n\n# Predicates\n\n@docs isSupersetOf, isSubsetOf, areDisjoint, any, all\n\n\n# Set operations\n\n@docs symmetricDifference\n\n\n# Mapping\n\n@docs concatMap, filterMap\n\n","unions":[],"aliases":[],"values":[{"name":"all","comment":" Determine if all elements satisfy some test.\n\n    import Set exposing (Set)\n\n    Set.Extra.all (\\n -> modBy 2 n == 0) (Set.fromList [ 2, 4 ])\n    --> True\n\n    Set.Extra.all (\\n -> modBy 2 n == 0) (Set.fromList [ 2, 3 ])\n    --> False\n\n    Set.Extra.all (\\n -> modBy 2 n == 0) Set.empty\n    --> True\n\n","type":"(a -> Basics.Bool) -> Set.Set a -> Basics.Bool"},{"name":"any","comment":" Determine if any elements satisfy some test.\n\n    import Set exposing (Set)\n\n    Set.Extra.any (\\n -> modBy 2 n == 0) (Set.fromList [ 2, 3 ])\n    --> True\n\n    Set.Extra.any (\\n -> modBy 2 n == 0) (Set.fromList [ 1, 3 ])\n    --> False\n\n    Set.Extra.any (\\n -> modBy 2 n == 0) Set.empty\n    --> False\n\n","type":"(a -> Basics.Bool) -> Set.Set a -> Basics.Bool"},{"name":"areDisjoint","comment":" A set is disjoint from another set if they have no elements in common.\n\n    import Set exposing (Set)\n\n    Set.Extra.areDisjoint\n        (Set.fromList [1,2,3])\n        (Set.fromList [3,4,5])\n    --> False\n\n    Set.Extra.areDisjoint\n        (Set.fromList [1,2,3])\n        (Set.fromList [4,5,6])\n    --> True\n\n","type":"Set.Set comparable -> Set.Set comparable -> Basics.Bool"},{"name":"concatMap","comment":" Map a given function onto a set and union the resulting set.\n\n    import Set exposing (Set)\n\n    neighbors : (Int, Int) -> Set (Int, Int)\n    neighbors (x, y) =\n        Set.fromList\n            [ (x - 1, y - 1), (x, y - 1), (x + 1, y - 1)\n            , (x - 1, y),                 (x + 1, y)\n            , (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)\n            ]\n\n    setOfPoints : Set (Int, Int)\n    setOfPoints =\n        Set.fromList [(1,1), (0,0)]\n\n    Set.Extra.concatMap neighbors setOfPoints\n    --> Set.fromList\n    -->     [ (-1,-1), (-1,0), (-1,1)\n    -->     , (0,-1), (0,0), (0,1)\n    -->     , (0,2), (1,-1), (1,0)\n    -->     , (1,1), (1,2), (2,0)\n    -->     , (2,1), (2,2)\n    -->     ]\n\n","type":"(comparable -> Set.Set comparable2) -> Set.Set comparable -> Set.Set comparable2"},{"name":"filterMap","comment":" Apply a function that may succeed to all values in the set, but only keep the successes.\n\n    import Set exposing (Set)\n\n    Set.fromList [\"1\", \"2\", \"a\", \"3\"]\n        |> Set.Extra.filterMap String.toFloat\n    --> Set.fromList [1, 2, 3]\n\n","type":"(comparable -> Maybe.Maybe comparable2) -> Set.Set comparable -> Set.Set comparable2"},{"name":"isSubsetOf","comment":" A set is a subset of another set if all the elements in the first set appear in the second set.\n\n    import Set exposing (Set)\n\n    Set.fromList [ 1, 2, 3 ]\n        |> Set.Extra.isSubsetOf (Set.fromList [1,2,3,4,5])\n    --> True\n\n","type":"Set.Set comparable -> Set.Set comparable -> Basics.Bool"},{"name":"isSupersetOf","comment":" A set is a superset of another set if all the elements in the second set appear in the first set.\n\n    import Set exposing (Set)\n\n\n    Set.fromList [ 1, 2, 3 ]\n        |> Set.Extra.isSupersetOf (Set.fromList [1,2,3,4,5])\n    --> False\n\nNote: This is just isSubsetOf with arguments reversed. It can be handy for dealing with pipelines.\n\n","type":"Set.Set comparable -> Set.Set comparable -> Basics.Bool"},{"name":"symmetricDifference","comment":" The symmetric difference between two sets is a set that contains all the elements that are in one of the two sets, but not both.\n\n    import Set exposing (Set)\n\n\n    Set.Extra.symmetricDifference\n        (Set.fromList [1,2,3])\n        (Set.fromList [3,4,5])\n        --> Set.fromList [1,2,4,5]\n\n","type":"Set.Set comparable -> Set.Set comparable -> Set.Set comparable"},{"name":"toggle","comment":" If the set does not contain the element, add it. If it does contain the element, remove it.\n\n    import Set exposing (Set)\n\n    Set.Extra.toggle 1 (Set.fromList [1,2,3])\n    --> Set.fromList [2, 3]\n\n    Set.Extra.toggle 1 (Set.fromList [2,3])\n    --> Set.fromList [1, 2, 3]\n\n","type":"comparable -> Set.Set comparable -> Set.Set comparable"}],"binops":[]},{"name":"String.Extra","comment":" Additional functions for working with Strings\n\n\n## Change words casing\n\n@docs toSentenceCase, toTitleCase, decapitalize\n\n\n## Inflector functions\n\nFunctions borrowed from the Rails Inflector class\n\n@docs camelize, classify, underscored, dasherize, humanize\n\n\n## Replace and Splice\n\n@docs replaceSlice, insertAt, nonEmpty, nonBlank, removeDiacritics\n\n\n## Splitting\n\n@docs break, softBreak\n\n\n## Wrapping\n\n@docs wrap, wrapWith, softWrap, softWrapWith, quote, surround\n\n\n## Checks\n\n@docs isBlank, countOccurrences\n\n\n## Formatting\n\n@docs clean, unquote, unsurround, unindent, ellipsis, softEllipsis, ellipsisWith, stripTags, pluralize\n\n\n## Converting Lists\n\n@docs toSentence, toSentenceOxford\n\n\n## Finding\n\n@docs rightOf, leftOf, rightOfBack, leftOfBack\n\n\n## Converting UTF-32\n\n@docs toCodePoints, fromCodePoints\n\n","unions":[],"aliases":[],"values":[{"name":"break","comment":" Break a string into a list of strings of a specified maximum length.\n\n    break 10 \"The quick brown fox\" --> [ \"The quick \", \"brown fox\" ]\n\n    break 2 \"\" --> [ \"\" ]\n\n","type":"Basics.Int -> String.String -> List.List String.String"},{"name":"camelize","comment":" Convert an underscored or dasherized string to a camelized one.\n\n    camelize \"-moz-transform\" --> \"MozTransform\"\n\n","type":"String.String -> String.String"},{"name":"classify","comment":" Convert a string to a camelized string starting with an uppercase letter.\nAll non-word characters will be stripped out of the original string.\n\n    classify \"some_class_name\" --> \"SomeClassName\"\n\n    classify \"myLittleCamel.class.name\" --> \"MyLittleCamelClassName\"\n\n","type":"String.String -> String.String"},{"name":"clean","comment":" Trim the whitespace of both sides of the string and compress\nrepeated whitespace internally to a single whitespace char.\n\n    clean \" The   quick brown   fox    \" --> \"The quick brown fox\"\n\n","type":"String.String -> String.String"},{"name":"countOccurrences","comment":" Return the number of occurrences of a substring in another string.\n\n    countOccurrences \"Hello\" \"Hello World\" --> 1\n\n    countOccurrences \"o\" \"Hello World\" --> 2\n\n","type":"String.String -> String.String -> Basics.Int"},{"name":"dasherize","comment":" Return a string joined by dashes after separating it by its uppercase characters.\nAny sequence of spaces or underscores will also be converted to a single dash.\nThe final string will be lowercased.\n\n    dasherize \"SomeClassName\" --> \"some-class-name\"\n\n    dasherize \"some_class_name\" --> \"some-class-name\"\n\n    dasherize \"someClass name\" --> \"some-class-name\"\n\n","type":"String.String -> String.String"},{"name":"decapitalize","comment":" Decapitalize the first letter of a string.\n\n    decapitalize \"This is a phrase\" --> \"this is a phrase\"\n\n    decapitalize \"Hello, World\" --> \"hello, World\"\n\n","type":"String.String -> String.String"},{"name":"ellipsis","comment":" Truncate the string at the specified length if the string is\nlonger than the specified length, and replace the end of the truncated\nstring with `\"...\"`, such that the resulting string is of the\nspecified length.\n\nThe resulting string will have at most the specified length.\n\n    ellipsis 5 \"Hello World\" --> \"He...\"\n\n    ellipsis 10 \"Hello World\" --> \"Hello W...\"\n\n    ellipsis 10 \"Hello\" --> \"Hello\"\n\n    ellipsis 8 \"Hello World\" --> \"Hello...\"\n\n","type":"Basics.Int -> String.String -> String.String"},{"name":"ellipsisWith","comment":" Truncate the second string at the specified length if the string is\nlonger than the specified length, and replace the end of the truncated\nstring with the first string, such that the resulting string is of the\nspecified length.\n\nThe resulting string will have at most the specified length.\n\n    ellipsisWith 5 \" ..\" \"Hello World\" --> \"He ..\"\n\n    ellipsisWith 10 \" ..\" \"Hello World\" --> \"Hello W ..\"\n\n    ellipsisWith 10 \" ..\" \"Hello\" --> \"Hello\"\n\n    ellipsisWith 8 \" ..\" \"Hello World\" --> \"Hello ..\"\n\n","type":"Basics.Int -> String.String -> String.String -> String.String"},{"name":"fromCodePoints","comment":" Convert a list of UTF-32 code points into a string. Inverse of\n`toCodePoints`.\n\n    fromCodePoints [ 97, 98, 99 ] --> \"abc\"\n\n    fromCodePoints [ 169, 167, 960 ] --> \"©§π\"\n\n    fromCodePoints [ 128169, 33 ] --> \"💩!\"\n\n`fromCodePoints codePoints` is equivalent to:\n\n    String.fromList (List.map Char.fromCode codePoints)\n\n","type":"List.List Basics.Int -> String.String"},{"name":"humanize","comment":" Convert an underscored, camelized, or dasherized string into one that can be\nread by humans. Also remove beginning and ending whitespace, and removes the\npostfix '\\_id'. The first character will be capitalized.\n\n    humanize \"this_is_great\" --> \"This is great\"\n\n    humanize \"ThisIsGreat\" --> \"This is great\"\n\n    humanize \"this-is-great\" --> \"This is great\"\n\n    humanize \"author_id\" --> \"Author\"\n\n","type":"String.String -> String.String"},{"name":"insertAt","comment":" Insert a substring at the specified index.\n\n    insertAt \"world\" 6 \"Hello \" --> \"Hello world\"\n\n","type":"String.String -> Basics.Int -> String.String -> String.String"},{"name":"isBlank","comment":" Test if a string is empty or only contains whitespace.\n\n    isBlank \"\" --> True\n\n    isBlank \"\\n\" --> True\n\n    isBlank \"  \" --> True\n\n    isBlank \" a\" --> False\n\n","type":"String.String -> Basics.Bool"},{"name":"leftOf","comment":" Search a string from left to right for a pattern and return a substring\nconsisting of the characters in the string that are to the left of the pattern.\n\n    leftOf \"_\" \"This_is_a_test_string\" --> \"This\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"leftOfBack","comment":" Search a string from right to left for a pattern and return a substring\nconsisting of the characters in the string that are to the left of the pattern.\n\n    leftOfBack \"_\" \"This_is_a_test_string\" --> \"This_is_a_test\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"nonBlank","comment":" Convert a string to a Nothing when blank.\n\n    nonBlank \"\" --> Nothing\n\n    nonBlank \" \" --> Nothing\n\n    nonBlank \"Hello world\" --> Just \"Hello world\"\n\n","type":"String.String -> Maybe.Maybe String.String"},{"name":"nonEmpty","comment":" Convert a string to a Nothing when empty.\n\n    nonEmpty \"\" --> Nothing\n\n    nonEmpty \"Hello world\" --> Just \"Hello world\"\n\n","type":"String.String -> Maybe.Maybe String.String"},{"name":"pluralize","comment":" Given a number, a singular string, and a plural string, return the number\nfollowed by a space, followed by either the singular string if the number was 1,\nor the plural string otherwise.\n\n    pluralize \"elf\" \"elves\" 2 --> \"2 elves\"\n\n    pluralize \"elf\" \"elves\" 1 --> \"1 elf\"\n\n    pluralize \"elf\" \"elves\" 0 --> \"0 elves\"\n\n**Note:** This will only work in English and if you anticipate needing to translate\nyour application into multiple languages, you would be better served by adopting\na [package better prepared to handle various languages](https://package.elm-lang.org/packages/GlobalWebIndex/elm-plural-rules/latest/PluralRules).\n\n","type":"String.String -> String.String -> Basics.Int -> String.String"},{"name":"quote","comment":" Add quotes to a string.\n\n    quote \"foo\" --> \"\\\"foo\\\"\"\n\n","type":"String.String -> String.String"},{"name":"removeDiacritics","comment":" Removes diactritics, it will expand\nknown ligatures, thus changing the string glyph length.\nAll non latin characters are untouched.\n\n    removeDiacritics \"La liberté commence où l'ignorance finit.\"\n\n    --> \"La liberte commence ou l'ignorance finit.\"\n    removeDiacritics \"é()/& abc\" --> \"e()/& abc\"\n\n    removeDiacritics \"こんにちは\" --> \"こんにちは\"\n\n","type":"String.String -> String.String"},{"name":"replaceSlice","comment":" Replace text within a portion of a string given a substitution\nstring, a start index and an end index. The substitution includes the character\nat the start index but not the one at the end index.\n\n    replaceSlice \"Sue\" 4 7 \"Hi, Bob\" --> \"Hi, Sue\"\n\n    replaceSlice \"elephants\" 0 6 \"snakes on a plane!\" --> \"elephants on a plane!\"\n\n    replaceSlice \"under\" 7 9 \"snakes on a plane!\" --> \"snakes under a plane!\"\n\n","type":"String.String -> Basics.Int -> Basics.Int -> String.String -> String.String"},{"name":"rightOf","comment":" Search a string from left to right for a pattern and return a substring\nconsisting of the characters in the string that are to the right of the pattern.\n\n    rightOf \"_\" \"This_is_a_test_string\" --> \"is_a_test_string\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"rightOfBack","comment":" Search a string from right to left for a pattern and return a substring\nconsisting of the characters in the string that are to the right of the pattern.\n\n    rightOfBack \"_\" \"This_is_a_test_string\" --> \"string\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"softBreak","comment":" Break a string into a list of strings of a specified maximum length,\nwithout truncating words.\n\n    softBreak 6 \"The quick brown fox\" --> [ \"The \", \"quick \", \"brown \", \"fox\" ]\n\n","type":"Basics.Int -> String.String -> List.List String.String"},{"name":"softEllipsis","comment":" Truncate the string at the last complete word less than or equal to\nthe specified length and append `\"...\"`. When the specified length is\nless than the length of the first word, the ellipsis is appended to the\nfirst word. When the specified length is greater than or equal to the\nlength of the string, an identical string is returned.\n\nIn contrast to `ellipsis`, this function will not produce incomplete\nwords, and the resulting string can exceed the specified length. In\naddition, it removes trailing whitespace and punctuation characters at\nthe end of the truncated string.\n\n    softEllipsis 1 \"Hello, World\" --> \"Hello...\"\n\n    softEllipsis 5 \"Hello, World\" --> \"Hello...\"\n\n    softEllipsis 6 \"Hello, World\" --> \"Hello...\"\n\n    softEllipsis 15 \"Hello, cruel world\" --> \"Hello, cruel...\"\n\n    softEllipsis 10 \"Hello\" --> \"Hello\"\n\n","type":"Basics.Int -> String.String -> String.String"},{"name":"softWrap","comment":" Chop a given string into parts of a given width without breaking words apart,\nand then separate them using a new line.\n\n    softWrap 9 \"My very long text\" --> \"My very\\nlong text\"\n\n    softWrap 3 \"Hello World\" --> \"Hello\\nWorld\"\n\n    softWrap 100 \"Too short\" --> \"Too short\"\n\n","type":"Basics.Int -> String.String -> String.String"},{"name":"softWrapWith","comment":" Chop a given string into parts of a given width without breaking words apart,\nand then separate them using the given separator.\n\n    softWrapWith 9 \"...\" \"My very long text\" --> \"My very...long text\"\n\n    softWrapWith 3 \"\\n\" \"Hello World\" --> \"Hello\\nWorld\"\n\n    softWrapWith 100 \"\\t\" \"Too short\" --> \"Too short\"\n\n","type":"Basics.Int -> String.String -> String.String -> String.String"},{"name":"stripTags","comment":" Remove all HTML tags from the string, preserving the text inside them.\n\n    stripTags \"a <a href=\\\"#\\\">link</a>\" --> \"a link\"\n\n    stripTags \"<script>alert('hello world!')</script>\" --> \"alert('hello world!')\"\n\n","type":"String.String -> String.String"},{"name":"surround","comment":" Surround a string with another string.\n\n    surround \"bar\" \"foo\" --> \"barfoobar\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"toCodePoints","comment":" Convert a string into a list of UTF-32 code points.\n\n    toCodePoints \"abc\" --> [ 97, 98, 99 ]\n\n    toCodePoints \"©§π\" --> [ 169, 167, 960 ]\n\n    toCodePoints \"💩!\" --> [ 128169, 33 ]\n\nNote that code points do not necessarily correspond to logical/visual\ncharacters, since it is possible for things like accented characters to be\nrepresented as two separate UTF-32 code points (a base character and a\ncombining accent).\n\n`toCodePoints string` is equivalent to:\n\n    List.map Char.toCode (String.toList string)\n\n","type":"String.String -> List.List Basics.Int"},{"name":"toSentence","comment":" Convert a list of strings into a human-readable list.\n\n    toSentence [] --> \"\"\n\n    toSentence [ \"lions\" ] --> \"lions\"\n\n    toSentence [ \"lions\", \"tigers\" ] --> \"lions and tigers\"\n\n    toSentence [ \"lions\", \"tigers\", \"bears\" ] --> \"lions, tigers and bears\"\n\n","type":"List.List String.String -> String.String"},{"name":"toSentenceCase","comment":" Capitalize the first letter of a string.\n\n    toSentenceCase \"this is a phrase\" --> \"This is a phrase\"\n\n    toSentenceCase \"hello, world\" --> \"Hello, world\"\n\n","type":"String.String -> String.String"},{"name":"toSentenceOxford","comment":" Convert a list of strings into a human-readable list using an oxford comma.\n\n    toSentenceOxford [] --> \"\"\n\n    toSentenceOxford [ \"lions\" ] --> \"lions\"\n\n    toSentenceOxford [ \"lions\", \"tigers\" ] --> \"lions and tigers\"\n\n    toSentenceOxford [ \"lions\", \"tigers\", \"bears\" ] --> \"lions, tigers, and bears\"\n\n","type":"List.List String.String -> String.String"},{"name":"toTitleCase","comment":" Capitalize the first character of each word in a string.\n\n    toTitleCase \"this is a phrase\" --> \"This Is A Phrase\"\n\n    toTitleCase \"hello, world\" --> \"Hello, World\"\n\n","type":"String.String -> String.String"},{"name":"underscored","comment":" Return a string joined by underscores after separating it by its uppercase characters.\nAny sequence of spaces or dashes will also be converted to a single underscore.\nThe final string will be lowercased.\n\n    underscored \"SomeClassName\" --> \"some_class_name\"\n\n    underscored \"some-class-name\" --> \"some_class_name\"\n\n    underscored \"SomeClass name\" --> \"some_class_name\"\n\n","type":"String.String -> String.String"},{"name":"unindent","comment":" Remove the shortest sequence of leading spaces or tabs on each line\nof the string, so that at least one of the lines will not have any\nleading spaces nor tabs and the rest of the lines will have the same\namount of indentation removed.\n\n    unindent \"  Hello\\n    World\" --> \"Hello\\n  World\"\n\n    unindent \"\\t\\tHello\\n\\t\\t\\t\\tWorld\" --> \"Hello\\n\\t\\tWorld\"\n\n","type":"String.String -> String.String"},{"name":"unquote","comment":" Remove quotes that surround a string.\n\n    unquote \"\\\"foo\\\"\" --> \"foo\"\n\n    unquote \"\\\"foo\\\"bar\\\"\" --> \"foo\\\"bar\"\n\n","type":"String.String -> String.String"},{"name":"unsurround","comment":" Remove surrounding strings from another string.\n\n    unsurround \"foo\" \"foobarfoo\" --> \"bar\"\n\n","type":"String.String -> String.String -> String.String"},{"name":"wrap","comment":" Chop a given string into parts of a given width, separating them with a\nnew line.\n\n    wrap 7 \"My very long text\" --> \"My very\\n long t\\next\"\n\n    wrap 100 \"Too short\" --> \"Too short\"\n\n","type":"Basics.Int -> String.String -> String.String"},{"name":"wrapWith","comment":" Separate a string into parts of a given width, using a given separator.\n\nLook at `wrap` if you just want to wrap using newlines.\n\n    wrapWith 7 \"\\n\" \"My very long text\" --> \"My very\\n long t\\next\"\n\n    wrapWith 100 \"\\n\" \"Too short\" --> \"Too short\"\n\n","type":"Basics.Int -> String.String -> String.String -> String.String"}],"binops":[]},{"name":"Triple.Extra","comment":" Convenience functions for 3-Tuples (also known as Triple).\n\nPlease remember the following from the Tuple documentation:\n\n> For more complex data, it is best to switch to records. So instead of representing a 3D point as `(3,4,5)` and not having any helper functions, represent it as `{ x = 3, y = 4, z = 5 }` and use all the built-in record syntax!\n\nThis is good advice! However triples do have their usecases for anonymous groupings and as such having some helper functions can be quite helpful.\n\n@docs Triple\n\n\n# Create\n\n@docs triple, from\n\n\n# Access\n\n@docs first, second, third\n\n\n# Manipulating\n\n@docs apply, sortWith\n\n\n# Mapping\n\n@docs map, mapFirst, mapSecond, mapThird\n\n\n# Lists\n\n@docs toList\n\n","unions":[],"aliases":[{"name":"Triple","comment":" By type aliasing Triples into a \"normal\" type, we remove the (small) effort\nrequired in reading types and signatures that have Triples in. This\nis most beneficial when a Triple is nested inside another type. Visually, the\nTriple type is now no different to List, Maybe, or Result.\n\nFor example, this:\n\n    List (Maybe ( String, Int, Char ))\n\nbecomes:\n\n    List (Maybe (Triple String Int Char))\n\n","args":["a","b","c"],"type":"( a, b, c )"}],"values":[{"name":"apply","comment":" Given a function that takes three arguments, apply that function to the three\nvalues contained in a Triple.\n\n    ( 1, 2, Array.fromList [0,1,2,3,4] )\n        |> Triple.Extra.apply Array.slice\n        --> Array.fromList [1,2,3]\n\n","type":"(a -> b -> c -> d) -> ( a, b, c ) -> d"},{"name":"first","comment":" Extract the first value from a triple.\n","type":"( a, b, c ) -> a"},{"name":"from","comment":" Occasionally you might want to create a Triple from a single value. This does\njust that.\n\n    Triple.Extra.from 1 --> ( 1, 1, 1 )\n\n","type":"a -> ( a, a, a )"},{"name":"map","comment":" Apply a function to all values contained in a Triple.\n\n    Triple.Extra.map negate ( -3, 10, -7 )\n        --> ( 3, -10, 7 )\n\n","type":"(a -> b) -> ( a, a, a ) -> ( b, b, b )"},{"name":"mapFirst","comment":" Transform the first value in a triple.\n\n    Triple.Extra.mapFirst negate ( -3, 10, '9' )\n        --> ( 3, 10, '9' )\n\n","type":"(a -> x) -> ( a, b, c ) -> ( x, b, c )"},{"name":"mapSecond","comment":" Transform the second value in a triple.\n\n    Triple.Extra.mapSecond negate ( -3, 10, '9' )\n        --> ( -3, 010, '9' )\n\n","type":"(b -> x) -> ( a, b, c ) -> ( a, x, c )"},{"name":"mapThird","comment":" Transform the third value in a triple.\n\n    Triple.Extra.mapThird String.toUpper ( -3, 10, \"a\" )\n        --> ( -3, 10, \"A\" )\n\n","type":"(c -> x) -> ( a, b, c ) -> ( a, b, x )"},{"name":"second","comment":" Extract the second value from a triple.\n","type":"( a, b, c ) -> b"},{"name":"sortWith","comment":" Similar to List.sortWith but for Triples instead of lists. Instead of\nconverting values contained in a Triple to `comparable`s, instead supply a\nfunction that will produce an `Order` directly.\n\n    Triple.Extra.sortWith Basics.compare ( 2, 1, 3 )\n        --> ( 1, 2, 3 )\n\n","type":"(a -> a -> Basics.Order) -> ( a, a, a ) -> ( a, a, a )"},{"name":"third","comment":" Extract the third value from a triple.\n","type":"( a, b, c ) -> c"},{"name":"toList","comment":" Turns a triple into a list of three elements.\n\n    Triple.Extra.toList ( 1, 2, 3 )\n        --> [ 1, 2, 3 ]\n\n","type":"( a, a, a ) -> List.List a"},{"name":"triple","comment":" Create a triple.\n","type":"a -> b -> c -> ( a, b, c )"}],"binops":[]},{"name":"Tuple.Extra","comment":" Convenience functions for 2-Tuples (also known as pairs).\n\n@docs Tuple\n\n\n# Paring\n\n@docs pairWith, from\n\n\n# Manipulating\n\n@docs apply, flip, join, joinBy, sum, product, sort, sortBy, sortWith\n\n\n# Mapping\n\n@docs map\n\n","unions":[],"aliases":[{"name":"Tuple","comment":" By type aliasing tuples into a \"normal\" type, we remove the (small) effort\nrequired in reading types and signatures that have tuples in. I've found this\nis most beneficial when a tuple is nested inside another type. Visually, the\nTuple type is now no different to List, Maybe, or Result.\n\nFor example, this:\n\n    List (Maybe ( String, Int ))\n\nbecomes:\n\n    List (Maybe (Tuple String Int))\n\n","args":["a","b"],"type":"( a, b )"}],"values":[{"name":"apply","comment":" Given a function that takes two arguments, apply that function to the two\nvalues contained in a tuple.\n\n    Tuple.Extra.apply (+) ( 1, 2 )\n        --> 3\n\n","type":"(a -> b -> c) -> ( a, b ) -> c"},{"name":"flip","comment":" Flip the two values contained in a tuple.\n","type":"( a, b ) -> ( b, a )"},{"name":"from","comment":" Occasionally you might want to create a Tuple from a single value. This does\njust that.\n\n    Tuple.Extra.from 1 --> ( 1, 1 )\n\n","type":"a -> ( a, a )"},{"name":"join","comment":" Similar to String.join but for tuples instead of lists. Given some separator\nstring, join together two strings in a tuple.\n\n    Tuple.Extra.join \" \" ( \"Hello\", \"world\" )\n        --> \"Hello world\"\n\n","type":"appendable -> ( appendable, appendable ) -> appendable"},{"name":"joinBy","comment":" Works just like join, but first converts the values of the tuple to strings.\nThese means the function works with any type of tuple.\n\n    Tuple.Extra.joinBy String.fromInt suitToString \" of \" ( 7, Club )\n        == \"Seven of Clubs\"\n\n","type":"(a -> appendable) -> (b -> appendable) -> appendable -> ( a, b ) -> appendable"},{"name":"map","comment":" Apply a function to both values contained in a tuple. This might also be\nknown as `mapBothWith` or `bimap`.\n\n    Tuple.Extra.map negate ( -3, 10 )\n        --> ( 3, -10 )\n\n","type":"(a -> b) -> ( a, a ) -> ( b, b )"},{"name":"pairWith","comment":" In certain situations, this proves more \"pipe friendly\" than the standard\n`Tuple.pair`. Fits nicely in your `update` function.\n\n    { model | count = model.count + 1 }\n        |> Tuple.Extra.pairWith Cmd.none\n\n","type":"b -> a -> ( a, b )"},{"name":"product","comment":" Similar to List.sum but for tuples instead of lists. Multiplies together two\nnumbers contained in a tuple\n\n    Tuple.Extra.product ( 1, 2 )\n        --> 2\n\n","type":"( number, number ) -> number"},{"name":"sort","comment":" Similar to List.sort but for tuples instead of lists. Sort values contained\nin a tuple from lowest to highest\n\n    Tuple.Extra.sort ( 2, 1 )\n        --> ( 1, 2 )\n\n","type":"( comparable, comparable ) -> ( comparable, comparable )"},{"name":"sortBy","comment":" Similar to List.sortBy but for tuples instead of lists. Sort values\ncontained in a tuple by first converting both values to a `comparable`. The\nvalues are sorted lowest to highest\n\n    Tuple.Extra.sortBy String.length ( \"mouse\", \"cat\" )\n        --> ( \"cat\", \"mouse\" )\n\n","type":"(a -> comparable) -> ( a, a ) -> ( a, a )"},{"name":"sortWith","comment":" Similar to List.sortWith but for tuples instead of lists. Instead of\nconverting values contained in a tuple to `comparable`s, instead supply a\nfunction that will produce an `Order` directly.\n\n    Tuple.Extra.sortWith Basics.compare ( 2, 1 )\n        --> ( 1, 2 )\n\n","type":"(a -> a -> Basics.Order) -> ( a, a ) -> ( a, a )"},{"name":"sum","comment":" Similar to List.sum but for tuples instead of lists. Adds together two\nnumbers contained in a tuple.\n\n    Tuple.Extra.sum ( 1, 2 )\n        --> 3\n\n","type":"( number, number ) -> number"}],"binops":[]}]